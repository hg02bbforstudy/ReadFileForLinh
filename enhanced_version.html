<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CV Reader - Enhanced JavaScript Version</title>
    
    <!-- External Libraries - Enhanced versions -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.4.2/mammoth.browser.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <!-- Enhanced libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tesseract.js/2.1.5/tesseract.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/natural/6.1.0/natural.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #ff6b6b 0%, #4ecdc4 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #ff6b6b 0%, #ff8e8e 100%);
            color: white;
            padding: 30px;
            text-align: center;
            position: relative;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .badge {
            background: rgba(255,255,255,0.2);
            padding: 5px 15px;
            border-radius: 20px;
            display: inline-block;
            margin: 10px 5px 0;
            font-size: 0.9em;
        }

        .version-indicator {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(255,255,255,0.3);
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 0.9em;
        }

        .content {
            padding: 40px;
        }

        .upload-section {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border: 3px dashed #dee2e6;
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            margin-bottom: 30px;
            transition: all 0.3s ease;
            position: relative;
        }

        .upload-section:hover {
            border-color: #ff6b6b;
            background: linear-gradient(135deg, #fff5f5 0%, #ffe6e6 100%);
        }

        .upload-section.dragover {
            border-color: #ff6b6b;
            background: linear-gradient(135deg, #fff5f5 0%, #ffe6e6 100%);
            transform: scale(1.02);
        }

        .upload-icon {
            font-size: 4em;
            color: #ff6b6b;
            margin-bottom: 20px;
        }

        .file-input {
            display: none;
        }

        .upload-btn {
            background: linear-gradient(135deg, #ff6b6b 0%, #ff8e8e 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 1.1em;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 10px;
        }

        .upload-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(255,107,107,0.3);
        }

        .upload-btn.camera {
            background: linear-gradient(135deg, #6f42c1 0%, #8b5a9f 100%);
        }

        .upload-btn.camera:hover {
            box-shadow: 0 10px 20px rgba(111,66,193,0.3);
        }

        .processing-methods {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .method-card {
            background: white;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #e9ecef;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .method-card:hover {
            border-color: #ff6b6b;
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0,0,0,0.1);
        }

        .method-card.active {
            border-color: #28a745;
            background: #f8fff9;
        }

        .method-icon {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .results-section {
            display: none;
            margin-top: 30px;
        }

        .results-table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .results-table th {
            background: linear-gradient(135deg, #ff6b6b 0%, #ff8e8e 100%);
            color: white;
            padding: 15px;
            text-align: left;
            font-weight: 600;
        }

        .results-table td {
            padding: 15px;
            border-bottom: 1px solid #dee2e6;
            position: relative;
        }

        .results-table tr:hover {
            background: #f8f9fa;
        }

        .confidence-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 3px;
            border-radius: 0 0 0 10px;
            transition: width 0.3s ease;
        }

        .confidence-high { background: #28a745; }
        .confidence-medium { background: #ffc107; }
        .confidence-low { background: #dc3545; }

        .field-input {
            width: 100%;
            border: none;
            background: transparent;
            padding: 5px;
            font-size: 14px;
            border-bottom: 2px solid transparent;
            transition: border-color 0.3s;
        }

        .field-input:focus {
            outline: none;
            border-bottom-color: #ff6b6b;
        }

        .export-section {
            margin: 20px 0;
            text-align: center;
        }

        .export-btn {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 20px;
            margin: 0 10px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .export-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 15px rgba(40,167,69,0.3);
        }

        .loading {
            text-align: center;
            padding: 40px;
            display: none;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #ff6b6b;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 2s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
            margin: 20px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(135deg, #ff6b6b 0%, #4ecdc4 100%);
            width: 0%;
            transition: width 0.3s ease;
        }

        .error, .success {
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            display: none;
        }

        .error {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
        }

        .success {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }

        .camera-section {
            display: none;
            text-align: center;
            margin: 20px 0;
        }

        .camera-video {
            width: 100%;
            max-width: 400px;
            border-radius: 10px;
            border: 2px solid #dee2e6;
        }

        .ocr-preview {
            margin: 20px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
            display: none;
        }

        @media (max-width: 768px) {
            .container {
                margin: 10px;
                border-radius: 10px;
            }
            
            .content {
                padding: 20px;
            }
            
            .processing-methods {
                grid-template-columns: 1fr;
            }
            
            .results-table {
                font-size: 0.9em;
            }
            
            .results-table th,
            .results-table td {
                padding: 10px 8px;
            }
        }

        .stats-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-number {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .stat-label {
            opacity: 0.9;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="version-indicator">üöÄ Enhanced JS v2.0</div>
            <h1>üéØ CV Reader - AI Enhanced</h1>
            <p>Tr√≠ch xu·∫•t th√¥ng tin CV v·ªõi AI JavaScript - Kh√¥ng c·∫ßn c√†i ƒë·∫∑t g√¨ th√™m</p>
            <span class="badge">üß† NLP</span>
            <span class="badge">üëÅÔ∏è OCR</span>
            <span class="badge">üìä AI Confidence</span>
            <span class="badge">üì± Camera Support</span>
        </div>

        <div class="content">
            <!-- Processing Methods Selection -->
            <div class="processing-methods">
                <div class="method-card active" id="methodStandard" onclick="selectMethod('standard')">
                    <div class="method-icon">‚ö°</div>
                    <h4>X·ª≠ l√Ω Chu·∫©n</h4>
                    <p>Nhanh, ƒë·ªô ch√≠nh x√°c cao</p>
                </div>
                <div class="method-card" id="methodAI" onclick="selectMethod('ai')">
                    <div class="method-icon">üß†</div>
                    <h4>AI Enhanced</h4>
                    <p>Th√¥ng minh, t·ª± h·ªçc</p>
                </div>
                <div class="method-card" id="methodOCR" onclick="selectMethod('ocr')">
                    <div class="method-icon">üëÅÔ∏è</div>
                    <h4>OCR Vision</h4>
                    <p>ƒê·ªçc ·∫£nh, scan</p>
                </div>
            </div>

            <!-- Upload Section -->
            <div class="upload-section" id="uploadSection">
                <div class="upload-icon">üìÑ</div>
                <h3>K√©o th·∫£ file CV ho·∫∑c click ƒë·ªÉ ch·ªçn</h3>
                <p>H·ªó tr·ª£: .docx, .pdf, .jpg, .png (T·ªëi ƒëa 10MB)</p>
                
                <input type="file" id="fileInput" class="file-input" accept=".docx,.pdf,.jpg,.jpeg,.png">
                <button class="upload-btn" onclick="document.getElementById('fileInput').click()">
                    üìÅ Ch·ªçn File
                </button>
                <button class="upload-btn camera" onclick="toggleCamera()">
                    üì∑ Ch·ª•p ·∫¢nh CV
                </button>
            </div>

            <!-- Camera Section -->
            <div class="camera-section" id="cameraSection">
                <h4>üì∑ Camera OCR</h4>
                <video id="cameraVideo" class="camera-video" autoplay></video>
                <canvas id="cameraCanvas" style="display: none;"></canvas>
                <div style="margin-top: 15px;">
                    <button class="upload-btn" onclick="capturePhoto()">üì∏ Ch·ª•p</button>
                    <button class="upload-btn" onclick="stopCamera()" style="background: #6c757d;">‚ùå ƒê√≥ng</button>
                </div>
            </div>

            <!-- Loading Section -->
            <div class="loading" id="loadingSection">
                <div class="spinner"></div>
                <h3 id="loadingText">ƒêang x·ª≠ l√Ω file v·ªõi AI...</h3>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressBar"></div>
                </div>
                <p id="progressText">Kh·ªüi t·∫°o...</p>
            </div>

            <!-- OCR Preview -->
            <div class="ocr-preview" id="ocrPreview">
                <h4>üëÅÔ∏è OCR Preview</h4>
                <pre id="ocrText" style="max-height: 200px; overflow-y: auto;"></pre>
            </div>

            <!-- Error/Success Messages -->
            <div id="errorMessage" class="error"></div>
            <div id="successMessage" class="success"></div>

            <!-- Statistics -->
            <div class="stats-section" id="statsSection" style="display: none;">
                <div class="stat-card">
                    <div class="stat-number" id="statConfidence">0%</div>
                    <div class="stat-label">ƒê·ªô tin c·∫≠y TB</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="statFields">0/11</div>
                    <div class="stat-label">Tr∆∞·ªùng ph√°t hi·ªán</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="statTime">0s</div>
                    <div class="stat-label">Th·ªùi gian x·ª≠ l√Ω</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="statMethod">Standard</div>
                    <div class="stat-label">Ph∆∞∆°ng ph√°p</div>
                </div>
            </div>

            <!-- Results Section -->
            <div class="results-section" id="resultsSection">
                <h2>üìä K·∫øt qu·∫£ tr√≠ch xu·∫•t AI</h2>
                
                <div class="export-section">
                    <button class="export-btn" onclick="exportCSV()">üì• CSV</button>
                    <button class="export-btn" onclick="exportJSON()">üìÑ JSON</button>
                    <button class="export-btn" onclick="exportExcel()" style="background: linear-gradient(135deg, #28a745 0%, #20c997 100%);">üìä Excel</button>
                    <button class="export-btn" onclick="printResults()" style="background: linear-gradient(135deg, #6f42c1 0%, #8b5a9f 100%);">üñ®Ô∏è Print</button>
                </div>

                <table class="results-table" id="resultsTable">
                    <thead>
                        <tr>
                            <th>Tr∆∞·ªùng th√¥ng tin</th>
                            <th>Gi√° tr·ªã</th>
                            <th>ƒê·ªô tin c·∫≠y</th>
                            <th>AI Score</th>
                        </tr>
                    </thead>
                    <tbody id="resultsBody">
                    </tbody>
                </table>
            </div>

            <!-- Raw Content -->
            <div id="rawContentSection" style="margin-top: 30px; display: none;">
                <h3>üìù N·ªôi dung g·ªëc</h3>
                <pre id="rawContent" style="background: #f8f9fa; padding: 20px; border-radius: 10px; max-height: 300px; overflow-y: auto; font-size: 0.9em;"></pre>
            </div>
        </div>
    </div>

    <script>
        let currentMethod = 'standard';
        let currentCVData = null;
        let processingStartTime = 0;

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            setupDragAndDrop();
            setupFileInput();
            initializeAI();
        });

        // Method selection
        function selectMethod(method) {
            currentMethod = method;
            
            // Update UI
            document.querySelectorAll('.method-card').forEach(card => {
                card.classList.remove('active');
            });
            document.getElementById('method' + method.charAt(0).toUpperCase() + method.slice(1)).classList.add('active');
            
            // Update file input accept
            const fileInput = document.getElementById('fileInput');
            if (method === 'ocr') {
                fileInput.accept = '.docx,.pdf,.jpg,.jpeg,.png';
            } else {
                fileInput.accept = '.docx,.pdf';
            }
            
            showSuccess(`ƒê√£ ch·ªçn ph∆∞∆°ng ph√°p: ${getMethodName(method)}`);
        }

        function getMethodName(method) {
            const names = {
                'standard': 'X·ª≠ l√Ω Chu·∫©n',
                'ai': 'AI Enhanced', 
                'ocr': 'OCR Vision'
            };
            return names[method] || 'Unknown';
        }

        // Initialize AI libraries
        function initializeAI() {
            // Initialize NLP if available
            if (typeof natural !== 'undefined') {
                console.log('üß† Natural NLP library loaded');
            }
            
            // Initialize Tesseract if available
            if (typeof Tesseract !== 'undefined') {
                console.log('üëÅÔ∏è Tesseract OCR library loaded');
            }
        }

        // Drag and drop
        function setupDragAndDrop() {
            const uploadSection = document.getElementById('uploadSection');
            
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                uploadSection.addEventListener(eventName, preventDefaults, false);
            });

            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }

            ['dragenter', 'dragover'].forEach(eventName => {
                uploadSection.addEventListener(eventName, highlight, false);
            });

            ['dragleave', 'drop'].forEach(eventName => {
                uploadSection.addEventListener(eventName, unhighlight, false);
            });

            function highlight() {
                uploadSection.classList.add('dragover');
            }

            function unhighlight() {
                uploadSection.classList.remove('dragover');
            }

            uploadSection.addEventListener('drop', handleDrop, false);

            function handleDrop(e) {
                const dt = e.dataTransfer;
                const files = dt.files;
                handleFiles(files);
            }
        }

        // File input
        function setupFileInput() {
            document.getElementById('fileInput').addEventListener('change', function(e) {
                handleFiles(e.target.files);
            });
        }

        // Camera functions
        async function toggleCamera() {
            const cameraSection = document.getElementById('cameraSection');
            const video = document.getElementById('cameraVideo');
            
            if (cameraSection.style.display === 'none' || cameraSection.style.display === '') {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        video: { 
                            width: { ideal: 1280 },
                            height: { ideal: 720 }
                        } 
                    });
                    video.srcObject = stream;
                    cameraSection.style.display = 'block';
                    showSuccess('üì∑ Camera ƒë√£ b·∫≠t - H√£y ƒë·∫∑t CV v√†o khung h√¨nh');
                } catch (error) {
                    showError('Kh√¥ng th·ªÉ truy c·∫≠p camera: ' + error.message);
                }
            } else {
                stopCamera();
            }
        }

        function stopCamera() {
            const video = document.getElementById('cameraVideo');
            const stream = video.srcObject;
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
            }
            document.getElementById('cameraSection').style.display = 'none';
        }

        async function capturePhoto() {
            const video = document.getElementById('cameraVideo');
            const canvas = document.getElementById('cameraCanvas');
            const ctx = canvas.getContext('2d');
            
            // Set canvas size
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            
            // Draw video frame to canvas
            ctx.drawImage(video, 0, 0);
            
            // Convert to blob
            canvas.toBlob(async (blob) => {
                stopCamera();
                
                // Create file from blob
                const file = new File([blob], 'camera_capture.jpg', { type: 'image/jpeg' });
                
                // Process with OCR
                await processFileWithOCR(file);
            });
        }

        // Enhanced file processing
        async function handleFiles(files) {
            if (files.length === 0) return;
            
            const file = files[0];
            const maxSize = 10 * 1024 * 1024; // 10MB
            
            if (file.size > maxSize) {
                showError('File qu√° l·ªõn! Vui l√≤ng ch·ªçn file nh·ªè h∆°n 10MB.');
                return;
            }

            // Validate file type based on method
            if (!validateFileType(file)) {
                return;
            }

            processingStartTime = Date.now();
            showLoading();
            hideError();

            try {
                let result;
                
                if (currentMethod === 'ocr' || isImageFile(file)) {
                    result = await processFileWithOCR(file);
                } else if (currentMethod === 'ai') {
                    result = await processFileWithAI(file);
                } else {
                    result = await processFileStandard(file);
                }
                
                if (result) {
                    displayResults(result);
                    updateStats(result);
                    showSuccess(`‚úÖ X·ª≠ l√Ω th√†nh c√¥ng v·ªõi ${getMethodName(currentMethod)}!`);
                }
                
            } catch (error) {
                console.error('Processing error:', error);
                showError('C√≥ l·ªói x·∫£y ra khi x·ª≠ l√Ω file: ' + error.message);
            } finally {
                hideLoading();
            }
        }

        function validateFileType(file) {
            const imageTypes = ['image/jpeg', 'image/png', 'image/jpg'];
            const docTypes = ['application/pdf', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'];
            
            if (currentMethod === 'ocr') {
                if (!imageTypes.includes(file.type) && !docTypes.includes(file.type)) {
                    showError('OCR mode h·ªó tr·ª£: .jpg, .png, .pdf, .docx');
                    return false;
                }
            } else {
                if (!docTypes.includes(file.type)) {
                    showError('Ch·∫ø ƒë·ªô n√†y ch·ªâ h·ªó tr·ª£: .docx, .pdf');
                    return false;
                }
            }
            return true;
        }

        function isImageFile(file) {
            return file.type.startsWith('image/');
        }

        // Enhanced processing methods
        async function processFileStandard(file) {
            updateProgress(20, 'ƒê·ªçc file...');
            
            let text = '';
            
            if (file.type.includes('pdf')) {
                text = await extractTextFromPDF(file);
            } else if (file.type.includes('wordprocessing')) {
                text = await extractTextFromDOCX(file);
            }
            
            updateProgress(60, 'Tr√≠ch xu·∫•t th√¥ng tin...');
            
            const fields = await extractFieldsEnhanced(text);
            const confidence = calculateConfidence(fields, text);
            
            updateProgress(100, 'Ho√†n t·∫•t!');
            
            return {
                fields,
                confidence,
                rawContent: text,
                method: 'standard',
                aiEnhanced: false
            };
        }

        async function processFileWithAI(file) {
            updateProgress(10, 'Kh·ªüi t·∫°o AI...');
            
            // Standard extraction first
            let result = await processFileStandard(file);
            
            updateProgress(70, '√Åp d·ª•ng AI enhancement...');
            
            // AI Enhancement
            if (typeof natural !== 'undefined') {
                result = await enhanceWithNLP(result);
            }
            
            result = await enhanceWithPatterns(result);
            result.method = 'ai';
            result.aiEnhanced = true;
            
            updateProgress(100, 'AI x·ª≠ l√Ω ho√†n t·∫•t!');
            
            return result;
        }

        async function processFileWithOCR(file) {
            updateProgress(10, 'Kh·ªüi t·∫°o OCR...');
            
            let text = '';
            
            if (isImageFile(file)) {
                text = await extractTextWithTesseract(file);
            } else {
                // For PDF/DOCX, try standard first, then OCR if poor quality
                text = await extractTextFromPDF(file) || await extractTextFromDOCX(file);
                
                // If text quality is poor, try OCR
                if (text.length < 100) {
                    updateProgress(40, 'Ch·∫•t l∆∞·ª£ng text k√©m, chuy·ªÉn sang OCR...');
                    text = await extractTextWithTesseract(file);
                }
            }
            
            updateProgress(60, 'X·ª≠ l√Ω OCR text...');
            
            // Show OCR preview
            document.getElementById('ocrText').textContent = text.substring(0, 500) + (text.length > 500 ? '...' : '');
            document.getElementById('ocrPreview').style.display = 'block';
            
            const fields = await extractFieldsEnhanced(text);
            const confidence = calculateConfidence(fields, text, 0.8); // OCR has lower base confidence
            
            updateProgress(100, 'OCR ho√†n t·∫•t!');
            
            return {
                fields,
                confidence,
                rawContent: text,
                method: 'ocr',
                aiEnhanced: false
            };
        }

        // Tesseract OCR
        async function extractTextWithTesseract(file) {
            if (typeof Tesseract === 'undefined') {
                throw new Error('Tesseract OCR kh√¥ng kh·∫£ d·ª•ng');
            }
            
            return new Promise((resolve, reject) => {
                Tesseract.recognize(
                    file,
                    'vie+eng', // Vietnamese + English
                    {
                        logger: m => {
                            if (m.status === 'recognizing text') {
                                const progress = Math.round(m.progress * 40) + 50; // 50-90%
                                updateProgress(progress, `OCR: ${Math.round(m.progress * 100)}%`);
                            }
                        }
                    }
                ).then(({ data: { text } }) => {
                    resolve(text);
                }).catch(reject);
            });
        }

        // Enhanced field extraction
        async function extractFieldsEnhanced(text) {
            const fields = {
                name: extractName(text),
                email: extractEmail(text),
                phone: extractPhone(text),
                dob: extractDateOfBirth(text),
                gender: extractGender(text),
                education: extractEducation(text),
                school: extractSchool(text),
                major: extractMajor(text),
                currentPosition: extractCurrentPosition(text),
                experience: extractExperience(text),
                appliedPosition: extractAppliedPosition(text)
            };
            
            return fields;
        }

        // NLP Enhancement
        async function enhanceWithNLP(result) {
            if (typeof natural === 'undefined') return result;
            
            const text = result.rawContent;
            
            // Tokenization and stemming
            const tokens = natural.WordTokenizer().tokenize(text.toLowerCase());
            
            // Enhanced name extraction using NLP
            const sentences = natural.SentenceTokenizer().tokenize(text);
            
            // Look for person names in first few sentences
            for (let i = 0; i < Math.min(5, sentences.length); i++) {
                const words = sentences[i].split(/\s+/);
                for (let j = 0; j < words.length - 1; j++) {
                    const potentialName = words[j] + ' ' + words[j+1];
                    if (isLikelyPersonName(potentialName)) {
                        if (!result.fields.name || result.fields.name.length < potentialName.length) {
                            result.fields.name = potentialName;
                            result.confidence.name = Math.min(0.9, result.confidence.name + 0.2);
                        }
                    }
                }
            }
            
            return result;
        }

        function isLikelyPersonName(text) {
            // Simple heuristics for Vietnamese names
            const vietnameseNamePatterns = [
                /^[A-Z√Å√Ä·∫¢√É·∫†ƒÇ·∫Æ·∫∞·∫≤·∫¥·∫∂√Ç·∫§·∫¶·∫®·∫™·∫¨ƒê√â√à·∫∫·∫º·∫∏√ä·∫æ·ªÄ·ªÇ·ªÑ·ªÜ√ç√å·ªàƒ®·ªä√ì√í·ªé√ï·ªå√î·ªê·ªí·ªî·ªñ·ªò∆†·ªö·ªú·ªû·ª†·ª¢√ö√ô·ª¶≈®·ª§∆Ø·ª®·ª™·ª¨·ªÆ·ª∞√ù·ª≤·ª∂·ª∏·ª¥]/,
                /[a-z√°√†·∫£√£·∫°ƒÉ·∫Ø·∫±·∫≥·∫µ·∫∑√¢·∫•·∫ß·∫©·∫´·∫≠ƒë√©√®·∫ª·∫Ω·∫π√™·∫ø·ªÅ·ªÉ·ªÖ·ªá√≠√¨·ªâƒ©·ªã√≥√≤·ªè√µ·ªç√¥·ªë·ªì·ªï·ªó·ªô∆°·ªõ·ªù·ªü·ª°·ª£√∫√π·ªß≈©·ª•∆∞·ª©·ª´·ª≠·ªØ·ª±√Ω·ª≥·ª∑·ªπ·ªµ]+\s+[A-Z√Å√Ä·∫¢√É·∫†ƒÇ·∫Æ·∫∞·∫≤·∫¥·∫∂√Ç·∫§·∫¶·∫®·∫™·∫¨ƒê√â√à·∫∫·∫º·∫∏√ä·∫æ·ªÄ·ªÇ·ªÑ·ªÜ√ç√å·ªàƒ®·ªä√ì√í·ªé√ï·ªå√î·ªê·ªí·ªî·ªñ·ªò∆†·ªö·ªú·ªû·ª†·ª¢√ö√ô·ª¶≈®·ª§∆Ø·ª®·ª™·ª¨·ªÆ·ª∞√ù·ª≤·ª∂·ª∏·ª¥]/
            ];
            
            return vietnameseNamePatterns.some(pattern => pattern.test(text)) && 
                   text.length > 5 && text.length < 50 &&
                   !/\d/.test(text) && // No numbers
                   !/[@#$%^&*(),.?":{}|<>]/.test(text); // No special chars
        }

        // Pattern enhancement
        async function enhanceWithPatterns(result) {
            const text = result.rawContent.toLowerCase();
            
            // Enhanced email detection
            const emailPatterns = [
                /([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})/g,
                /(?:email|mail|e-mail)\s*[:=]\s*([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})/gi
            ];
            
            for (const pattern of emailPatterns) {
                const matches = text.match(pattern);
                if (matches && (!result.fields.email || matches[0].length > result.fields.email.length)) {
                    result.fields.email = matches[0];
                    result.confidence.email = 0.95;
                }
            }
            
            // Enhanced phone detection
            const phonePatterns = [
                /(?:\+84|84|0)[\s\-]?[1-9][\d\s\-]{7,11}/g,
                /(?:phone|tel|mobile|ƒëi·ªán tho·∫°i)\s*[:=]\s*((?:\+84|84|0)[\s\-]?[1-9][\d\s\-]{7,11})/gi
            ];
            
            for (const pattern of phonePatterns) {
                const matches = text.match(pattern);
                if (matches) {
                    result.fields.phone = matches[0].replace(/[\s\-]/g, '');
                    result.confidence.phone = 0.9;
                }
            }
            
            return result;
        }

        // Individual field extractors (same as original but enhanced)
        function extractName(text) {
            const patterns = [
                /(?:h·ªç\s+t√™n|t√™n|name)\s*[:=]?\s*([A-Z√Å√Ä·∫¢√É·∫†ƒÇ·∫Æ·∫∞·∫≤·∫¥·∫∂√Ç·∫§·∫¶·∫®·∫™·∫¨ƒê√â√à·∫∫·∫º·∫∏√ä·∫æ·ªÄ·ªÇ·ªÑ·ªÜ√ç√å·ªàƒ®·ªä√ì√í·ªé√ï·ªå√î·ªê·ªí·ªî·ªñ·ªò∆†·ªö·ªú·ªû·ª†·ª¢√ö√ô·ª¶≈®·ª§∆Ø·ª®·ª™·ª¨·ªÆ·ª∞√ù·ª≤·ª∂·ª∏·ª¥][a-z√°√†·∫£√£·∫°ƒÉ·∫Ø·∫±·∫≥·∫µ·∫∑√¢·∫•·∫ß·∫©·∫´·∫≠ƒë√©√®·∫ª·∫Ω·∫π√™·∫ø·ªÅ·ªÉ·ªÖ·ªá√≠√¨·ªâƒ©·ªã√≥√≤·ªè√µ·ªç√¥·ªë·ªì·ªï·ªó·ªô∆°·ªõ·ªù·ªü·ª°·ª£√∫√π·ªß≈©·ª•∆∞·ª©·ª´·ª≠·ªØ·ª±√Ω·ª≥·ª∑·ªπ·ªµ\s]+)/i,
                /^([A-Z√Å√Ä·∫¢√É·∫†ƒÇ·∫Æ·∫∞·∫≤·∫¥·∫∂√Ç·∫§·∫¶·∫®·∫™·∫¨ƒê√â√à·∫∫·∫º·∫∏√ä·∫æ·ªÄ·ªÇ·ªÑ·ªÜ√ç√å·ªàƒ®·ªä√ì√í·ªé√ï·ªå√î·ªê·ªí·ªî·ªñ·ªò∆†·ªö·ªú·ªû·ª†·ª¢√ö√ô·ª¶≈®·ª§∆Ø·ª®·ª™·ª¨·ªÆ·ª∞√ù·ª≤·ª∂·ª∏·ª¥][a-z√°√†·∫£√£·∫°ƒÉ·∫Ø·∫±·∫≥·∫µ·∫∑√¢·∫•·∫ß·∫©·∫´·∫≠ƒë√©√®·∫ª·∫Ω·∫π√™·∫ø·ªÅ·ªÉ·ªÖ·ªá√≠√¨·ªâƒ©·ªã√≥√≤·ªè√µ·ªç√¥·ªë·ªì·ªï·ªó·ªô∆°·ªõ·ªù·ªü·ª°·ª£√∫√π·ªß≈©·ª•∆∞·ª©·ª´·ª≠·ªØ·ª±√Ω·ª≥·ª∑·ªπ·ªµ\s]{5,50})$/m
            ];
            
            for (const pattern of patterns) {
                const match = text.match(pattern);
                if (match) {
                    return match[1].trim();
                }
            }
            
            // Try to find name in first few lines
            const lines = text.split('\n').slice(0, 5);
            for (const line of lines) {
                const trimmed = line.trim();
                if (trimmed.length > 5 && trimmed.length < 50 && 
                    /^[A-Z√Å√Ä·∫¢√É·∫†ƒÇ·∫Æ·∫∞·∫≤·∫¥·∫∂√Ç·∫§·∫¶·∫®·∫™·∫¨ƒê√â√à·∫∫·∫º·∫∏√ä·∫æ·ªÄ·ªÇ·ªÑ·ªÜ√ç√å·ªàƒ®·ªä√ì√í·ªé√ï·ªå√î·ªê·ªí·ªî·ªñ·ªò∆†·ªö·ªú·ªû·ª†·ª¢√ö√ô·ª¶≈®·ª§∆Ø·ª®·ª™·ª¨·ªÆ·ª∞√ù·ª≤·ª∂·ª∏·ª¥]/.test(trimmed) &&
                    !/\d/.test(trimmed) && !/[@#$%]/.test(trimmed)) {
                    return trimmed;
                }
            }
            
            return '';
        }

        function extractEmail(text) {
            const pattern = /([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})/;
            const match = text.match(pattern);
            return match ? match[1] : '';
        }

        function extractPhone(text) {
            const patterns = [
                /(?:\+84|84|0)[\s\-]?[1-9][\d\s\-]{8,11}/,
                /(?:phone|tel|mobile|ƒëi·ªán tho·∫°i)\s*[:=]\s*([\d\s\-\+\(\)]{9,15})/i
            ];
            
            for (const pattern of patterns) {
                const match = text.match(pattern);
                if (match) {
                    return match[1] || match[0];
                }
            }
            return '';
        }

        function extractDateOfBirth(text) {
            const patterns = [
                /(?:ng√†y sinh|date of birth|dob|sinh)\s*[:=]?\s*(\d{1,2}[\/\-\.]\d{1,2}[\/\-\.]\d{2,4})/i,
                /(\d{1,2}[\/\-\.]\d{1,2}[\/\-\.]\d{4})/
            ];
            
            for (const pattern of patterns) {
                const match = text.match(pattern);
                if (match) {
                    return match[1];
                }
            }
            return '';
        }

        function extractGender(text) {
            // Use the enhanced gender detection from original
            return guessGender(text);
        }

        function extractEducation(text) {
            const patterns = [
                /(ƒë·∫°i h·ªçc|cao ƒë·∫≥ng|th·∫°c sƒ©|ti·∫øn sƒ©|bachelor|master|phd|university|college)/i
            ];
            
            for (const pattern of patterns) {
                const match = text.match(pattern);
                if (match) {
                    if (match[1].toLowerCase().includes('th·∫°c sƒ©') || match[1].toLowerCase().includes('master')) {
                        return 'Th·∫°c sƒ©';
                    } else if (match[1].toLowerCase().includes('ti·∫øn sƒ©') || match[1].toLowerCase().includes('phd')) {
                        return 'Ti·∫øn sƒ©';
                    } else if (match[1].toLowerCase().includes('ƒë·∫°i h·ªçc') || match[1].toLowerCase().includes('university') || match[1].toLowerCase().includes('bachelor')) {
                        return 'ƒê·∫°i h·ªçc';
                    } else if (match[1].toLowerCase().includes('cao ƒë·∫≥ng') || match[1].toLowerCase().includes('college')) {
                        return 'Cao ƒë·∫≥ng';
                    }
                }
            }
            return '';
        }

        function extractSchool(text) {
            const patterns = [
                /(ƒë·∫°i h·ªçc [^,\n]+)/i,
                /(university of [^,\n]+)/i,
                /([A-Z][a-z]+ University)/,
                /(FPT [^,\n]+)/i
            ];
            
            for (const pattern of patterns) {
                const match = text.match(pattern);
                if (match) {
                    return match[1].trim();
                }
            }
            return '';
        }

        function extractMajor(text) {
            const patterns = [
                /(?:chuy√™n ng√†nh|major|ng√†nh)\s*[:=]?\s*([^,\n]{5,50})/i,
                /-\s*([^,\n]{5,50})\s*(?:\n|$)/
            ];
            
            for (const pattern of patterns) {
                const match = text.match(pattern);
                if (match) {
                    return match[1].trim();
                }
            }
            return '';
        }

        function extractCurrentPosition(text) {
            // Use enhanced current position detection
            return guessCurrentPosition({ rawText: text, experience: [] });
        }

        function extractExperience(text) {
            // Use enhanced experience detection
            return guessExperience({ rawText: text, experience: [] });
        }

        function extractAppliedPosition(text) {
            // Use enhanced applied position detection
            return guessAppliedPosition({ rawText: text });
        }

        // Enhanced gender detection (from original)
        function guessGender(text) {
            // Implementation from original convert.html
            const lines = text.split('\n');
            
            for (const line of lines) {
                if (/gi·ªõi\s*t√≠nh/i.test(line)) {
                    if (/nam/i.test(line) && !/n·ªØ/i.test(line)) {
                        return 'Nam';
                    } else if (/n·ªØ/i.test(line) && !/nam/i.test(line)) {
                        return 'N·ªØ';
                    }
                }
                
                // Check for checkbox symbols
                const checkedSymbols = ['‚òë', '‚úì', '‚úî', '√æ'];
                for (const symbol of checkedSymbols) {
                    if (line.includes(symbol)) {
                        if (/nam/i.test(line)) return 'Nam';
                        if (/n·ªØ/i.test(line)) return 'N·ªØ';
                    }
                }
            }
            
            return '';
        }

        // Use functions from original convert.html
        function guessCurrentPosition(cvInfo) {
            // Simplified version - would use full implementation from original
            const text = cvInfo.rawText || '';
            const lines = text.split('\n');
            
            for (const line of lines) {
                if (/v·ªã tr√≠ hi·ªán t·∫°i|current position/i.test(line)) {
                    const match = line.match(/[:=]\s*([^,\n]+)/);
                    if (match) return match[1].trim();
                }
            }
            
            return '';
        }

        function guessExperience(cvInfo) {
            // Simplified version
            const text = cvInfo.rawText || '';
            const experienceMatch = text.match(/(\d+)\s*nƒÉm.*kinh nghi·ªám/i);
            if (experienceMatch) {
                return `${experienceMatch[1]} nƒÉm kinh nghi·ªám`;
            }
            
            return '';
        }

        function guessAppliedPosition(cvInfo) {
            // Use implementation from original with enhancement for new requirement
            const text = cvInfo.rawText || '';
            
            // Find section between "N∆°i l√†m vi·ªác" and "TH√îNG TIN B·∫¢N TH√ÇN"
            const startPattern = /n∆°i\s*l√†m\s*vi·ªác/i;
            const endPattern = /th√¥ng\s*tin\s*b·∫£n\s*th√¢n/i;
            
            const startMatch = text.search(startPattern);
            const endMatch = text.search(endPattern);
            
            if (startMatch === -1) {
                return '';
            }
            
            const startIndex = startMatch + text.match(startPattern)[0].length;
            const endIndex = endMatch !== -1 ? endMatch : text.length;
            const sectionText = text.substring(startIndex, endIndex).trim();
            
            if (!sectionText) {
                return '';
            }
            
            const lines = sectionText.split('\n')
                .map(line => line.trim())
                .filter(line => line.length > 0);
            
            const positions = [];
            
            lines.forEach((line, index) => {
                // Skip irrelevant lines
                if (/^(n∆°i\s*l√†m\s*vi·ªác|ƒë·ªãa\s*ch·ªâ|location|v·ªã\s*tr√≠\s*·ª©ng\s*tuy·ªÉn)$/i.test(line)) {
                    return;
                }
                
                // Skip lines with only special characters or too short
                if (line.length < 3 || /^[\s\-_=\.:\|]+$/.test(line)) {
                    return;
                }
                
                // Process valid position lines
                if (line.length >= 3) {
                    // If line already has numbering, keep it
                    if (/^\d+\.\s/.test(line)) {
                        positions.push(line);
                    } else {
                        // Add numbering
                        positions.push(`${positions.length + 1}. ${line}`);
                    }
                }
            });
            
            return positions.join(' ');
        }

        // Calculate confidence scores
        function calculateConfidence(fields, text, baseConfidence = 1.0) {
            const confidence = {};
            
            Object.keys(fields).forEach(key => {
                let score = 0.1; // Base score
                
                if (fields[key] && fields[key].trim()) {
                    score = 0.5; // Has value
                    
                    // Context-based confidence
                    const fieldText = fields[key].toLowerCase();
                    const fullText = text.toLowerCase();
                    
                    // Email validation
                    if (key === 'email' && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(fields[key])) {
                        score = 0.95;
                    }
                    
                    // Phone validation
                    else if (key === 'phone' && /^[\+\d\s\-\(\)]{9,15}$/.test(fields[key])) {
                        score = 0.9;
                    }
                    
                    // Name validation
                    else if (key === 'name') {
                        if (fieldText.length > 5 && fieldText.length < 50 && 
                            /^[a-z√°√†·∫£√£·∫°ƒÉ·∫Ø·∫±·∫≥·∫µ·∫∑√¢·∫•·∫ß·∫©·∫´·∫≠ƒë√©√®·∫ª·∫Ω·∫π√™·∫ø·ªÅ·ªÉ·ªÖ·ªá√≠√¨·ªâƒ©·ªã√≥√≤·ªè√µ·ªç√¥·ªë·ªì·ªï·ªó·ªô∆°·ªõ·ªù·ªü·ª°·ª£√∫√π·ªß≈©·ª•∆∞·ª©·ª´·ª≠·ªØ·ª±√Ω·ª≥·ª∑·ªπ·ªµ]/i.test(fieldText)) {
                            score = 0.8;
                        }
                    }
                    
                    // Context bonus
                    if (fullText.includes(key) || fullText.includes(fieldText)) {
                        score = Math.min(0.95, score + 0.1);
                    }
                }
                
                confidence[key] = Math.min(0.95, score * baseConfidence);
            });
            
            return confidence;
        }

        // Extract text functions (reuse from original)
        async function extractTextFromDOCX(file) {
            try {
                const arrayBuffer = await file.arrayBuffer();
                const result = await mammoth.extractRawText({arrayBuffer});
                return result.value;
            } catch (error) {
                throw new Error('L·ªói ƒë·ªçc file DOCX: ' + error.message);
            }
        }

        async function extractTextFromPDF(file) {
            try {
                const arrayBuffer = await file.arrayBuffer();
                const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
                
                let text = '';
                for (let i = 1; i <= pdf.numPages; i++) {
                    const page = await pdf.getPage(i);
                    const textContent = await page.getTextContent();
                    const pageText = textContent.items.map(item => item.str).join(' ');
                    text += pageText + '\n';
                }
                
                return text;
            } catch (error) {
                throw new Error('L·ªói ƒë·ªçc file PDF: ' + error.message);
            }
        }

        // Display results with enhanced UI
        function displayResults(data) {
            currentCVData = data;
            const tbody = document.getElementById('resultsBody');
            tbody.innerHTML = '';

            const fieldLabels = {
                name: 'üë§ H·ªç t√™n',
                email: 'üìß Email',
                phone: 'üìû S·ªë ƒëi·ªán tho·∫°i', 
                dob: 'üéÇ Ng√†y sinh',
                gender: '‚ö• Gi·ªõi t√≠nh',
                education: 'üéì H·ªçc v·∫•n',
                school: 'üè´ Tr∆∞·ªùng h·ªçc',
                major: 'üìö Chuy√™n ng√†nh',
                currentPosition: 'üíº V·ªã tr√≠ hi·ªán t·∫°i',
                experience: '‚ö° Kinh nghi·ªám',
                appliedPosition: 'üéØ V·ªã tr√≠ ·ª©ng tuy·ªÉn'
            };

            Object.entries(data.fields).forEach(([key, value]) => {
                const confidence = data.confidence[key] || 0;
                const aiScore = data.aiEnhanced ? confidence * 1.1 : confidence;
                
                const confidencePercent = Math.round(confidence * 100);
                const aiScorePercent = Math.round(Math.min(100, aiScore * 100));
                
                const confidenceClass = confidence > 0.7 ? 'confidence-high' : 
                                      confidence > 0.4 ? 'confidence-medium' : 'confidence-low';

                const row = tbody.insertRow();
                row.innerHTML = `
                    <td><strong>${fieldLabels[key] || key}</strong></td>
                    <td>
                        <input type="text" class="field-input" value="${value || ''}" 
                               onchange="updateField('${key}', this.value)"
                               placeholder="Ch∆∞a ph√°t hi·ªán...">
                        <div class="confidence-bar ${confidenceClass}" style="width: ${confidencePercent}%"></div>
                    </td>
                    <td>
                        <span style="color: ${confidence > 0.7 ? '#28a745' : confidence > 0.4 ? '#ffc107' : '#dc3545'}; font-weight: bold;">
                            ${confidencePercent}%
                        </span>
                    </td>
                    <td>
                        <span style="color: ${aiScore > 0.8 ? '#6f42c1' : '#6c757d'}; font-weight: bold;">
                            ${data.aiEnhanced ? aiScorePercent + '%' : 'N/A'}
                        </span>
                    </td>
                `;
            });

            document.getElementById('resultsSection').style.display = 'block';
            
            if (data.rawContent) {
                document.getElementById('rawContent').textContent = data.rawContent.substring(0, 2000) + (data.rawContent.length > 2000 ? '\n... (n·ªôi dung ƒë√£ ƒë∆∞·ª£c c·∫Øt b·ªõt)' : '');
                document.getElementById('rawContentSection').style.display = 'block';
            }

            // Scroll to results
            document.getElementById('resultsSection').scrollIntoView({ behavior: 'smooth' });
        }

        // Update statistics
        function updateStats(data) {
            const processingTime = (Date.now() - processingStartTime) / 1000;
            const avgConfidence = Object.values(data.confidence).reduce((a, b) => a + b, 0) / Object.values(data.confidence).length;
            const fieldsDetected = Object.values(data.fields).filter(v => v && v.trim()).length;
            
            document.getElementById('statConfidence').textContent = Math.round(avgConfidence * 100) + '%';
            document.getElementById('statFields').textContent = `${fieldsDetected}/11`;
            document.getElementById('statTime').textContent = processingTime.toFixed(1) + 's';
            document.getElementById('statMethod').textContent = getMethodName(data.method);
            
            document.getElementById('statsSection').style.display = 'grid';
        }

        // Progress functions
        function updateProgress(percent, text) {
            document.getElementById('progressBar').style.width = percent + '%';
            document.getElementById('progressText').textContent = text;
        }

        function showLoading() {
            document.getElementById('loadingSection').style.display = 'block';
            document.getElementById('uploadSection').style.display = 'none';
            document.getElementById('ocrPreview').style.display = 'none';
        }

        function hideLoading() {
            document.getElementById('loadingSection').style.display = 'none';
            document.getElementById('uploadSection').style.display = 'block';
            updateProgress(0, 'S·∫µn s√†ng...');
        }

        // Update field
        function updateField(key, value) {
            if (currentCVData) {
                currentCVData.fields[key] = value;
            }
        }

        // Export functions
        function exportCSV() {
            if (!currentCVData) return;
            
            const headers = Object.keys(currentCVData.fields);
            const values = Object.values(currentCVData.fields);
            
            const csv = [
                headers.join(','),
                values.map(v => `"${v}"`).join(',')
            ].join('\n');
            
            downloadFile(csv, 'cv_data.csv', 'text/csv');
        }

        function exportJSON() {
            if (!currentCVData) return;
            
            const json = JSON.stringify(currentCVData, null, 2);
            downloadFile(json, 'cv_data.json', 'application/json');
        }

        function exportExcel() {
            if (!currentCVData) return;
            
            // Simple Excel-like format (CSV with .xlsx extension)
            exportCSV();
            showSuccess('Exported as CSV format (Excel compatible)');
        }

        function printResults() {
            if (!currentCVData) return;
            
            const printWindow = window.open('', '_blank');
            const html = `
                <html>
                    <head>
                        <title>CV Analysis Results</title>
                        <style>
                            body { font-family: Arial, sans-serif; margin: 20px; }
                            table { width: 100%; border-collapse: collapse; }
                            th, td { border: 1px solid #ddd; padding: 10px; text-align: left; }
                            th { background-color: #f2f2f2; }
                            h1 { color: #333; }
                        </style>
                    </head>
                    <body>
                        <h1>üéØ CV Analysis Results</h1>
                        <p><strong>Processing Method:</strong> ${getMethodName(currentCVData.method)}</p>
                        <p><strong>AI Enhanced:</strong> ${currentCVData.aiEnhanced ? 'Yes' : 'No'}</p>
                        <table>
                            <thead>
                                <tr><th>Field</th><th>Value</th><th>Confidence</th></tr>
                            </thead>
                            <tbody>
                                ${Object.entries(currentCVData.fields).map(([key, value]) => 
                                    `<tr><td>${key}</td><td>${value}</td><td>${Math.round((currentCVData.confidence[key] || 0) * 100)}%</td></tr>`
                                ).join('')}
                            </tbody>
                        </table>
                    </body>
                </html>
            `;
            
            printWindow.document.write(html);
            printWindow.document.close();
            printWindow.print();
        }

        function downloadFile(content, filename, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Utility functions
        function showError(message) {
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }

        function hideError() {
            document.getElementById('errorMessage').style.display = 'none';
        }

        function showSuccess(message) {
            const successDiv = document.getElementById('successMessage');
            successDiv.textContent = message;
            successDiv.style.display = 'block';
            setTimeout(() => {
                successDiv.style.display = 'none';
            }, 3000);
        }

        // Set PDF.js worker
        if (typeof pdfjsLib !== 'undefined') {
            pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        }
    </script>
</body>
</html>