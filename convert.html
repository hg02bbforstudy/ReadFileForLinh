<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CV Document Reader - Tr√≠ch xu·∫•t th√¥ng tin t·ª´ DOCX/PDF</title>
    
    <!-- External Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.4.2/mammoth.browser.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <!-- Removed unused libraries: docx4js, docx-preview -->
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .main-content {
            padding: 40px;
        }

        .upload-section {
            background: #f8f9fa;
            border: 3px dashed #4facfe;
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            margin-bottom: 30px;
            transition: all 0.3s ease;
        }

        .upload-section:hover {
            border-color: #00f2fe;
            background: #e3f2fd;
        }

        .upload-section.dragover {
            border-color: #ff6b6b;
            background: #ffe0e0;
        }

        .file-input {
            display: none;
        }

        .upload-btn {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 1.1em;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(79, 172, 254, 0.3);
        }

        .upload-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 7px 20px rgba(79, 172, 254, 0.4);
        }

        .file-info {
            margin-top: 15px;
            font-size: 0.9em;
            color: #666;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: #e0e0e0;
            border-radius: 3px;
            margin-top: 15px;
            overflow: hidden;
            display: none;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4facfe, #00f2fe);
            width: 0%;
            transition: width 0.3s ease;
        }

        .results-section {
            display: none;
            margin-top: 30px;
        }

        .results-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-top: 20px;
        }

        .result-card {
            background: #fff;
            border: 1px solid #e0e0e0;
            border-radius: 10px;
            padding: 25px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.05);
            transition: all 0.3s ease;
        }

        .result-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
        }

        .result-card h3 {
            color: #333;
            margin-bottom: 15px;
            font-size: 1.3em;
            border-bottom: 2px solid #4facfe;
            padding-bottom: 10px;
        }

        .info-item {
            margin-bottom: 12px;
            padding: 8px 0;
            border-bottom: 1px solid #f0f0f0;
        }

        .info-label {
            font-weight: bold;
            color: #4facfe;
            display: inline-block;
            width: 120px;
        }

        .info-value {
            color: #333;
        }

        .raw-content {
            grid-column: 1 / -1;
            max-height: 400px;
            overflow-y: auto;
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #e0e0e0;
        }

        .raw-content h3 {
            margin-bottom: 15px;
            color: #333;
        }

        .raw-content pre {
            white-space: pre-wrap;
            word-wrap: break-word;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            line-height: 1.4;
            color: #555;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 20px;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #4facfe;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error {
            background: #ffe6e6;
            color: #d32f2f;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            border: 1px solid #ffcdd2;
        }

        .success {
            background: #e8f5e8;
            color: #2e7d32;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            border: 1px solid #c8e6c9;
        }

        @media (max-width: 768px) {
            .results-grid {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            
            .main-content {
                padding: 20px;
            }
            
            .header h1 {
                font-size: 2em;
            }
        }

        /* Table styles */
        #resultsTable tbody td {
            padding: 6px;
            border: 1px solid #ddd;
            font-size: 0.75em;
            line-height: 1.3;
            vertical-align: top;
            word-wrap: break-word;
            white-space: normal;
        }
        
        #resultsTable tbody tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        
        #resultsTable tbody tr:hover {
            background-color: #f0f8ff;
        }
        
        .delete-btn {
            background-color: #ff4757;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.7em;
        }
        
        .delete-btn:hover {
            background-color: #ff3742;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üìÑ CV Document Reader</h1>
            <p>Tr√≠ch xu·∫•t th√¥ng tin t·ª´ file DOCX v√† PDF m·ªôt c√°ch th√¥ng minh</p>
        </div>
        
        <div class="main-content">
            <div class="upload-section" id="uploadSection">
                <div class="upload-icon">üìÇ</div>
                <h3 style="margin: 20px 0;">K√©o th·∫£ file ho·∫∑c click ƒë·ªÉ ch·ªçn</h3>
                <p>H·ªó tr·ª£: DOCX, PDF (t·ªëi ƒëa 10MB)</p>
                <input type="file" id="fileInput" class="file-input" accept=".docx,.pdf" />
                <button class="upload-btn" onclick="document.getElementById('fileInput').click()">Ch·ªçn File</button>
                <div class="file-info" id="fileInfo"></div>
                <div class="progress-bar" id="progressBar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
            </div>

            <div class="loading" id="loading">
                <div class="spinner"></div>
                <p>ƒêang x·ª≠ l√Ω file...</p>
            </div>

            <div class="results-section" id="resultsSection" style="display:none;">
                <h2>üéØ Th√¥ng tin ƒë∆∞·ª£c tr√≠ch xu·∫•t</h2>
                <button id="saveBtn" class="upload-btn" style="margin-bottom:20px;">L∆∞u v√†o danh s√°ch</button>
                <div class="table-wrapper" style="overflow-x:auto; max-height:400px; border:1px solid #ddd; border-radius:8px;">
                    <table id="resultsTable" style="width:100%;border-collapse:collapse; font-size:0.85em;">
                        <thead>
                            <tr style="background:#4facfe; color:white; position:sticky; top:0; z-index:10;">
                                <th style="padding:8px; border:1px solid #ddd; min-width:40px; font-size:0.8em;">STT</th>
                                <th style="padding:8px; border:1px solid #ddd; min-width:120px; font-size:0.8em;">H·ªç v√† t√™n</th>
                                <th style="padding:8px; border:1px solid #ddd; min-width:50px; font-size:0.8em;">Title</th>
                                <th style="padding:8px; border:1px solid #ddd; min-width:150px; font-size:0.8em;">Mail</th>
                                <th style="padding:8px; border:1px solid #ddd; min-width:100px; font-size:0.8em;">S·ªë ƒëi·ªán tho·∫°i</th>
                                <th style="padding:8px; border:1px solid #ddd; min-width:80px; font-size:0.8em;">Ng√†y sinh</th>
                                <th style="padding:8px; border:1px solid #ddd; min-width:60px; font-size:0.8em;">Gi·ªõi t√≠nh</th>
                                <th style="padding:8px; border:1px solid #ddd; min-width:80px; font-size:0.8em;">H·ªçc v·∫•n</th>
                                <th style="padding:8px; border:1px solid #ddd; min-width:120px; font-size:0.8em;">Tr∆∞·ªùng ƒê√†o t·∫°o</th>
                                <th style="padding:8px; border:1px solid #ddd; min-width:100px; font-size:0.8em;">Chuy√™n ng√†nh</th>
                                <th style="padding:8px; border:1px solid #ddd; min-width:120px; font-size:0.8em;">V·ªã tr√≠ hi·ªán t·∫°i</th>
                                <th style="padding:8px; border:1px solid #ddd; min-width:150px; font-size:0.8em;">Kinh nghi·ªám c√¥ng t√°c</th>
                                <th style="padding:8px; border:1px solid #ddd; min-width:120px; font-size:0.8em;">V·ªã tr√≠ ·ª©ng tuy·ªÉn</th>
                                <th style="padding:8px; border:1px solid #ddd; min-width:60px; font-size:0.8em;">X√≥a</th>
                            </tr>
                        </thead>
                        <tbody id="resultsBody">
                        </tbody>
                    </table>
                </div>
                <div class="result-card raw-content" style="margin-top:30px;">
                    <h3>üìù N·ªôi dung g·ªëc</h3>
                    <pre id="rawContent"></pre>
                </div>
            </div>
        </div>
    </div>

    <script>
        // PDF.js worker setup
        if (typeof pdfjsLib !== 'undefined') {
            pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        }

        // File upload handling
        const fileInput = document.getElementById('fileInput');
        const uploadSection = document.getElementById('uploadSection');
        const fileInfo = document.getElementById('fileInfo');
        const progressBar = document.getElementById('progressBar');
        const progressFill = document.getElementById('progressFill');
        const loading = document.getElementById('loading');
        const resultsSection = document.getElementById('resultsSection');

        // Drag and drop events
        uploadSection.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadSection.classList.add('dragover');
        });

        uploadSection.addEventListener('dragleave', () => {
            uploadSection.classList.remove('dragover');
        });

        uploadSection.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadSection.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        });

        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFile(e.target.files[0]);
            }
        });

        function handleFile(file) {
            // Validate file
            const validTypes = ['application/vnd.openxmlformats-officedocument.wordprocessingml.document', 'application/pdf'];
            const maxSize = 10 * 1024 * 1024; // 10MB

            if (!validTypes.includes(file.type)) {
                showError('Vui l√≤ng ch·ªçn file DOCX ho·∫∑c PDF');
                return;
            }

            if (file.size > maxSize) {
                showError('File kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° 10MB');
                return;
            }

            // Show file info
            fileInfo.innerHTML = `
                <strong>File ƒë∆∞·ª£c ch·ªçn:</strong> ${file.name}<br>
                <strong>K√≠ch th∆∞·ªõc:</strong> ${(file.size / 1024 / 1024).toFixed(2)} MB<br>
                <strong>Lo·∫°i:</strong> ${file.type.includes('pdf') ? 'PDF' : 'DOCX'}
            `;

            // Process file
            processFile(file);
        }

        async function processFile(file) {
            showLoading(true);
            hideError();
            
            try {
                let extractedText = '';
                let htmlContent = null;
                
                if (file.type.includes('pdf')) {
                    extractedText = await extractTextFromPDF(file);
                } else if (file.type.includes('wordprocessingml')) {
                    const docxResult = await extractTextFromDOCX(file);
                    extractedText = docxResult.text;
                    htmlContent = docxResult.html;
                    
                    if (docxResult.checkboxGender) {

                        // S·∫Ω ƒë∆∞·ª£c s·ª≠ d·ª•ng trong analyzeCVContent
                        window.docxCheckboxGender = docxResult.checkboxGender;
                    }
                }
                
                if (extractedText) {
                    const cvInfo = analyzeCVContent(extractedText, htmlContent);
                    displayResults(cvInfo, extractedText);
                    showLoading(false);
                } else {
                    throw new Error('Kh√¥ng th·ªÉ tr√≠ch xu·∫•t n·ªôi dung t·ª´ file');
                }
            } catch (error) {
                showLoading(false);
                showError('L·ªói khi x·ª≠ l√Ω file: ' + error.message);
            }
        }

        async function extractTextFromPDF(file) {
            return new Promise((resolve, reject) => {
                const fileReader = new FileReader();
                fileReader.onload = async function() {
                    try {
                        const typedarray = new Uint8Array(this.result);
                        const pdf = await pdfjsLib.getDocument(typedarray).promise;
                        let fullText = '';
                        
                        for (let i = 1; i <= pdf.numPages; i++) {
                            const page = await pdf.getPage(i);
                            const textContent = await page.getTextContent();
                            
                            // S·∫Øp x·∫øp text items theo v·ªã tr√≠ tr√™n trang
                            const items = textContent.items.sort((a, b) => {
                                // S·∫Øp x·∫øp theo chi·ªÅu d·ªçc tr∆∞·ªõc (top to bottom)
                                if (Math.abs(a.transform[5] - b.transform[5]) > 5) {
                                    return b.transform[5] - a.transform[5];
                                }
                                // Sau ƒë√≥ s·∫Øp x·∫øp theo chi·ªÅu ngang (left to right)
                                return a.transform[4] - b.transform[4];
                            });
                            
                            let currentLine = '';
                            let lastY = null;
                            
                            for (const item of items) {
                                const y = item.transform[5];
                                

                                
                                // N·∫øu l√† d√≤ng m·ªõi (kh√°c bi·ªát v·ªÅ v·ªã tr√≠ Y)
                                if (lastY !== null && Math.abs(y - lastY) > 5) {
                                    if (currentLine.trim()) {
                                        fullText += currentLine.trim() + '\n';
                                    }
                                    currentLine = item.str;
                                } else {
                                    // C√πng d√≤ng, n·ªëi text
                                    if (currentLine && !currentLine.endsWith(' ') && !item.str.startsWith(' ')) {
                                        currentLine += ' ';
                                    }
                                    currentLine += item.str;
                                }
                                
                                lastY = y;
                            }
                            
                            // Th√™m d√≤ng cu·ªëi c√πng
                            if (currentLine.trim()) {
                                fullText += currentLine.trim() + '\n';
                            }
                        }
                        
                        resolve(fullText);
                    } catch (error) {
                        reject(error);
                    }
                };
                fileReader.onerror = () => reject(new Error('L·ªói ƒë·ªçc file PDF'));
                fileReader.readAsArrayBuffer(file);
            });
        }


        


        // Function s·ª≠ d·ª•ng docx4js ƒë·ªÉ parse DOCX v·ªõi form controls
        async function parseDocxWithDocx4js(arrayBuffer) {
            try {
                const docx = docx4js.load(arrayBuffer);
                
                // Traverse document ƒë·ªÉ t√¨m form fields
                let foundGender = null;
                
                docx.parse({
                    "w:checkBox": function(node, parser) {

                        
                        // Ki·ªÉm tra checked state
                        const checked = node.querySelector('w\\:checked, checked');
                        const checkedValue = checked ? checked.getAttribute('w:val') || checked.getAttribute('val') : null;
                        

                        
                        if (checkedValue === '1' || checkedValue === 'true') {
                            // T√¨m text g·∫ßn checkbox
                            const parentText = this.getParentText(node);

                            
                            if (/nam/i.test(parentText)) {
                                foundGender = 'Nam';
                            } else if (/n·ªØ/i.test(parentText)) {
                                foundGender = 'N·ªØ';
                            }
                        }
                    },
                    
                    "w:fldChar": function(node, parser) {

                        
                        if (node.getAttribute('w:fldCharType') === 'begin') {
                            // T√¨m FORMCHECKBOX
                            const nextNodes = this.getNextSiblings(node, 5);
                            for (const sibling of nextNodes) {
                                if (sibling.textContent && sibling.textContent.includes('FORMCHECKBOX')) {

                                    // Logic x·ª≠ l√Ω form checkbox
                                }
                            }
                        }
                    }
                });
                
                return foundGender;
                
            } catch (error) {
                console.error('Error with docx4js:', error);
                return null;
            }
        }
        
        // Enhanced XML parsing with Unicode symbol detection
        async function parseDocxXMLWithSymbols(arrayBuffer) {
            try {
                const zip = await JSZip.loadAsync(arrayBuffer);
                const documentXml = await zip.file("word/document.xml").async("text");
                
                // T√¨m w:sym elements (Word symbols)
                const symbolPattern = /<w:sym\s+w:font="[^"]*"\s+w:char="([^"]*)"/gi;
                const symbols = [];
                let match;
                
                while ((match = symbolPattern.exec(documentXml)) !== null) {
                    const charCode = match[1];
                    const unicodeChar = String.fromCharCode(parseInt(charCode, 16));
                    symbols.push({
                        charCode: charCode,
                        unicodeChar: unicodeChar,
                        position: match.index
                    });

                }
                
                // T√¨m text runs xung quanh symbols
                if (symbols.length > 0) {
                    for (const symbol of symbols) {
                        const surroundingXml = documentXml.substring(symbol.position - 1000, symbol.position + 1000);
                        
                        // Extract text t·ª´ XML xung quanh symbol
                        const textMatches = surroundingXml.match(/<w:t[^>]*>([^<]*)<\/w:t>/g);
                        if (textMatches) {
                            const surroundingTexts = textMatches.map(t => t.replace(/<[^>]*>/g, ''));
                            const combinedText = surroundingTexts.join(' ').toLowerCase();
                            

                            
                            // Check if this is checkbox symbol v·ªõi gender
                            if (combinedText.includes('gi·ªõi') || combinedText.includes('t√≠nh')) {
                                // Determine if it's checked symbol
                                const checkedCodes = ['2611', '2713', '2714', '25A0', '25CF', '25C9']; // ‚òë‚úì‚úî‚ñ†‚óè‚óâ
                                
                                if (checkedCodes.includes(symbol.charCode.toUpperCase())) {

                                    
                                    if (combinedText.includes('nam') && !combinedText.includes('n·ªØ')) {
                                        return 'Nam';
                                    } else if (combinedText.includes('n·ªØ') && !combinedText.includes('nam')) {
                                        return 'N·ªØ';
                                    }
                                }
                            }
                        }
                    }
                }
                
                // Fallback: t√¨m direct Unicode symbols trong text content
                const allTextPattern = /<w:t[^>]*>([^<]*)<\/w:t>/g;
                const allTexts = [];
                
                while ((match = allTextPattern.exec(documentXml)) !== null) {
                    allTexts.push(match[1]);
                }
                
                const fullText = allTexts.join(' ');

                
                // Check for Unicode checkbox symbols directly in text
                const symbolResult = analyzeWordSymbolCheckboxes(fullText);
                if (symbolResult) {
                    return symbolResult;
                }
                
                return null;
                
            } catch (error) {
                console.error('Error in XML symbol parsing:', error);
                return null;
            }
        }

        // Alternative: Parse b·∫±ng c√°ch kh√°c - ƒë·ªçc to√†n b·ªô XML v√† regex
        async function parseDocxAlternative(arrayBuffer) {
            try {

                
                const zip = await JSZip.loadAsync(arrayBuffer);
                
                // ƒê·ªçc t·∫•t c·∫£ XML files c√≥ th·ªÉ ch·ª©a form data
                const files = ['word/document.xml', 'word/header1.xml', 'word/header2.xml', 'word/footer1.xml'];
                
                for (const fileName of files) {
                    const file = zip.file(fileName);
                    if (file) {
                        const xmlContent = await file.async('text');

                        

                        if (xmlContent.toLowerCase().includes('gi·ªõi')) {
                            const genderSection = xmlContent.match(/.{0,500}gi·ªõi.{0,500}/gi);
                            if (genderSection) {

                            }
                        }
                        
                        // T√¨m t·∫•t c·∫£ text elements xung quanh checkbox
                        const genderResult = analyzeXMLForGender(xmlContent);
                        if (genderResult) {
                            return genderResult;
                        }
                    }
                }
                
                // Method cu·ªëi: Th·ª≠ t√¨m trong styles.xml v√† other files
                const otherFiles = Object.keys(zip.files).filter(name => name.endsWith('.xml'));

                
                for (const fileName of otherFiles) {
                    if (!files.includes(fileName)) {
                        const file = zip.file(fileName);
                        const content = await file.async('text');
                        if (content.toLowerCase().includes('checkbox') || content.toLowerCase().includes('formfield')) {

                        }
                    }
                }
                
                return null;
            } catch (error) {
                console.error('Error in alternative parsing:', error);
                return null;
            }
        }
        
        // Helper function ƒë·ªÉ analyze XML cho gender
        function analyzeXMLForGender(xmlContent) {

            
            // T√¨m t·∫•t c·∫£ text runs (w:t elements)
            const textPattern = /<w:t[^>]*>([^<]*)<\/w:t>/g;
            const allTexts = [];
            let match;
            
            while ((match = textPattern.exec(xmlContent)) !== null) {
                allTexts.push({
                    text: match[1],
                    index: match.index
                });
            }
            

            
            // T√¨m pattern gender v·ªõi checkbox symbols ho·∫∑c spacing
            for (let i = 0; i < allTexts.length; i++) {
                const current = allTexts[i];
                const text = current.text.toLowerCase();
                
                        // Pattern 1: Text c√≥ ch·ª©a checkbox symbols (expanded list)
                        const checkboxSymbols = ['‚òê', '‚òë', '‚úì', '‚úî', '‚úó', '‚úò', '‚ñ°', '‚ñ†', '‚ñ¢', '‚ñ£', '√æ', '‚óØ', '‚óè', '‚óã', '‚óâ', '‚àÖ', '‚äó', '‚äï'];
                        const checkedSymbols = ['‚òë', '‚úì', '‚úî', '‚ñ†', '‚ñ£', '√æ', '‚óè', '‚óâ', '‚äó', '‚äï'];
                        
                        const hasSymbol = checkboxSymbols.some(symbol => current.text.includes(symbol));
                        if (hasSymbol) {

                            
                            // Ki·ªÉm tra symbol n√†o l√† checked
                            for (const checkedSymbol of checkedSymbols) {
                                if (current.text.includes(checkedSymbol)) {
                                    if (/nam/i.test(current.text)) {
                                        return 'Nam';
                                    } else if (/n·ªØ/i.test(current.text)) {
                                        return 'N·ªØ';
                                    }
                                }
                            }
                        }                // Pattern 2: T√¨m "gi·ªõi t√≠nh" v√† check c√°c text elements ti·∫øp theo
                if (text.includes('gi·ªõi') && text.includes('t√≠nh')) {

                    
                    for (let j = i + 1; j < Math.min(i + 10, allTexts.length); j++) {
                        const nextText = allTexts[j].text;

                        
                        // Ki·ªÉm tra n·∫øu c√≥ t·∫•t c·∫£ options trong m·ªôt d√≤ng ‚Üí skip
                        if (/nam.*n·ªØ/i.test(nextText) || /n·ªØ.*nam/i.test(nextText)) {

                            continue;
                        }
                        
                        // Ch·ªâ accept n·∫øu l√† standalone gender
                        if (/^\s*nam\s*$/i.test(nextText)) {
                            return 'Nam';
                        } else if (/^\s*n·ªØ\s*$/i.test(nextText)) {
                            return 'N·ªØ';
                        }
                    }
                }
            }
            
            return null;
        }

        // Function m·ªõi ƒë·ªÉ parse DOCX XML tr·ª±c ti·∫øp v√† t√¨m checkbox
        async function parseDocxXMLForCheckbox(arrayBuffer) {
            try {

                const zip = await JSZip.loadAsync(arrayBuffer);
                const documentXml = await zip.file("word/document.xml").async("text");
                

                
                // T√¨m checkbox elements trong XML
                const checkboxPatterns = [
                    // Form checkbox elements
                    /<w:checkBox[^>]*>[\s\S]*?<\/w:checkBox>/gi,
                    /<w:fldChar[^>]*w:fldCharType="begin"[^>]*>[\s\S]*?<w:instrText[^>]*>\s*FORMCHECKBOX[\s\S]*?<w:fldChar[^>]*w:fldCharType="end"/gi,
                    
                    // Legacy form fields
                    /<w:ffData[^>]*>[\s\S]*?<w:checkBox[^>]*>[\s\S]*?<\/w:ffData>/gi,
                    
                    // Content control checkboxes
                    /<w:sdt[^>]*>[\s\S]*?<w:checkbox[^>]*>[\s\S]*?<\/w:sdt>/gi,
                    
                    // Symbol checkboxes (‚òê‚òë‚úì) 
                    /<w:sym[^>]*w:char="[\u2610\u2611\u2713\u2714]"/gi
                ];
                
                let foundCheckboxes = [];
                
                for (let i = 0; i < checkboxPatterns.length; i++) {
                    const matches = documentXml.match(checkboxPatterns[i]);
                    if (matches) {

                        foundCheckboxes = foundCheckboxes.concat(matches);
                    }
                }
                
                if (foundCheckboxes.length > 0) {

                    
                    // Analyze checkbox states
                    for (const checkbox of foundCheckboxes) {

                        
                        // Check for checked state
                        const isChecked = checkbox.includes('w:checked="1"') || 
                                        checkbox.includes('w:checked="true"') ||
                                        checkbox.includes('w:default="1"') ||
                                        checkbox.includes('\u2611') || // ‚òë
                                        checkbox.includes('\u2713') || // ‚úì  
                                        checkbox.includes('\u2714');   // ‚úî
                                        

                        
                        if (isChecked) {
                            // T√¨m text g·∫ßn checkbox ƒë·ªÉ x√°c ƒë·ªãnh gender
                            const surroundingText = await findTextAroundCheckbox(documentXml, checkbox);

                            
                            if (/nam/i.test(surroundingText)) {
                                return 'Nam';
                            } else if (/n·ªØ/i.test(surroundingText)) {
                                return 'N·ªØ';
                            }
                        }
                    }
                }
                
                return null;
            } catch (error) {
                console.error('Error parsing DOCX XML:', error);
                return null;
            }
        }
        
        // Function ƒë·ªÉ detect Word symbol checkboxes
        function analyzeWordSymbolCheckboxes(line) {

            
            // Word checkbox symbols th∆∞·ªùng d√πng
            const checkboxSymbols = [
                '‚òê', '‚òë', '‚úì', '‚úî', '‚úó', '‚úò', 
                '‚ñ°', '‚ñ†', '‚ñ¢', '‚ñ£', 
                '√æ', // PDF style
                '‚óØ', '‚óè', '‚óã', '‚óâ', // Circles
                '‚àÖ', '‚äó', '‚äï', // Other symbols
                'üóÜ', 'üóá', // Ballot symbols
            ];
            

            
            // T√¨m t·∫•t c·∫£ symbols trong d√≤ng
            const foundSymbols = [];
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (checkboxSymbols.includes(char)) {
                    foundSymbols.push({
                        symbol: char,
                        position: i,
                        context: line.substring(Math.max(0, i-10), Math.min(line.length, i+20))
                    });
                }
            }
            
            if (foundSymbols.length > 0) {

                
                // Ph√¢n t√≠ch t·ª´ng symbol
                for (const symb of foundSymbols) {
                    const beforeText = line.substring(0, symb.position).toLowerCase();
                    const afterText = line.substring(symb.position + 1).toLowerCase();
                    

                    
                    // Checked symbols
                    const checkedSymbols = ['‚òë', '‚úì', '‚úî', '‚ñ†', '‚ñ£', '√æ', '‚óè', '‚óâ', '‚äó', '‚äï'];
                    
                    if (checkedSymbols.includes(symb.symbol)) {
                        
                        // T√¨m gender g·∫ßn symbol n√†y
                        if (/nam/.test(afterText.slice(0, 10)) || /nam/.test(beforeText.slice(-10))) {
                            return 'Nam';
                        } else if (/n·ªØ/.test(afterText.slice(0, 10)) || /n·ªØ/.test(beforeText.slice(-10))) {
                            return 'N·ªØ';
                        }
                    } else {
                    }
                }
            }
            
            return null;
        }

        // Function ƒë·ªÉ ph√¢n t√≠ch spacing patterns trong gender options
        function analyzeSpacingForSelection(line) {
            
            // Tr∆∞·ªõc ti√™n, th·ª≠ t√¨m Word symbols
            const symbolResult = analyzeWordSymbolCheckboxes(line);
            if (symbolResult) {
                return symbolResult;
            }
            
            
            // T√°ch c√°c t·ª´ v√† kho·∫£ng tr·∫Øng
            const parts = line.split(/(\s+)/);
            
            // T√¨m v·ªã tr√≠ c·ªßa Nam, N·ªØ, Kh√°c
            const namIndex = line.toLowerCase().indexOf('nam');
            const nuIndex = line.toLowerCase().indexOf('n·ªØ');
            const khacIndex = line.toLowerCase().indexOf('kh√°c');
            
            
            // Ph√¢n t√≠ch s·ªë spaces gi·ªØa c√°c option
            if (namIndex !== -1 && nuIndex !== -1) {
                const spaceBetweenNamNu = nuIndex - namIndex - 3; // 3 = length of "nam"
                
                if (nuIndex !== -1 && khacIndex !== -1) {
                    const spaceBetweenNuKhac = khacIndex - nuIndex - 2; // 2 = length of "n·ªØ"
                    
                    // Pattern analysis:
                    // N·∫øu c√≥ spacing b·∫•t th∆∞·ªùng, c√≥ th·ªÉ l√† indication
                    if (spaceBetweenNamNu < spaceBetweenNuKhac / 2) {
                        return 'Nam';
                    } else if (spaceBetweenNuKhac < spaceBetweenNamNu / 2) {
                        return 'N·ªØ';
                    }
                }
            }
            
            // Ki·ªÉm tra character patterns ƒë·∫∑c bi·ªát
            const hasSpecialCharsAroundNam = /[^\w\s]nam|nam[^\w\s]/i.test(line);
            const hasSpecialCharsAroundNu = /[^\w\s]n·ªØ|n·ªØ[^\w\s]/i.test(line);
            
            if (hasSpecialCharsAroundNam && !hasSpecialCharsAroundNu) {
                return 'Nam';
            } else if (hasSpecialCharsAroundNu && !hasSpecialCharsAroundNam) {
                return 'N·ªØ';
            }
            
            return null;
        }

        // Helper function ƒë·ªÉ t√¨m text xung quanh checkbox
        async function findTextAroundCheckbox(documentXml, checkboxXml) {
            // T√¨m v·ªã tr√≠ checkbox trong document
            const checkboxIndex = documentXml.indexOf(checkboxXml.substring(0, 50));
            
            // L·∫•y text tr∆∞·ªõc v√† sau checkbox (500 characters)
            const start = Math.max(0, checkboxIndex - 500);
            const end = Math.min(documentXml.length, checkboxIndex + checkboxXml.length + 500);
            const surroundingXml = documentXml.substring(start, end);
            
            // Extract text t·ª´ XML surrounding area
            const textPattern = /<w:t[^>]*>([^<]*)<\/w:t>/g;
            let texts = [];
            let match;
            
            while ((match = textPattern.exec(surroundingXml)) !== null) {
                texts.push(match[1]);
            }
            
            return texts.join(' ');
        }

        // Parse Wingdings checkbox symbols trong DOCX XML
        function parseWingdingsCheckboxes(documentXml) {
            

            const EMPTY_CHECKBOX = 'F0A8';  // ‚òê
            const CHECKED_CHECKBOX = 'F0FE'; // ‚òë
            
            // T√¨m t·∫•t c·∫£ w:sym elements
            const symbolPattern = /<w:sym\s+w:font="Wingdings"\s+w:char="([^"]*)"[^>]*>/g;
            const symbols = [];
            let match;
            
            while ((match = symbolPattern.exec(documentXml)) !== null) {
                symbols.push({
                    charCode: match[1],
                    position: match.index,
                    isChecked: match[1].toUpperCase() === CHECKED_CHECKBOX
                });
            }
            
            
            if (symbols.length === 0) {
                return null;
            }
            
            // T√¨m text elements xung quanh m·ªói symbol
            for (let i = 0; i < symbols.length; i++) {
                const symbol = symbols[i];
                
                // L·∫•y XML context xung quanh symbol (¬±300 chars)
                const start = Math.max(0, symbol.position - 300);
                const end = Math.min(documentXml.length, symbol.position + 300);
                const context = documentXml.substring(start, end);
                
                // Extract text t·ª´ context
                const textMatches = context.match(/<w:t[^>]*>([^<]*)<\/w:t>/g);
                if (textMatches) {
                    const texts = textMatches.map(t => t.replace(/<[^>]*>/g, '')).filter(t => t.trim());
                    const contextText = texts.join(' ').toLowerCase();
                    
                    
                    // Check if context contains gender info v√† symbol ƒë∆∞·ª£c check
                    const hasGenderContext = contextText.includes('gi·ªõi') || contextText.includes('t√≠nh');
                    const hasNam = contextText.includes('nam');
                    const hasNu = contextText.includes('n·ªØ');
                    
                    if (symbol.isChecked && (hasNam || hasNu)) {
                        
                        if (hasNam && !hasNu) {
                            return 'Nam';
                        } else if (hasNu && !hasNam) {
                            return 'N·ªØ';
                        } else if (hasNam && hasNu) {
                            // Context c√≥ c·∫£ Nam v√† N·ªØ - c·∫ßn ph√¢n t√≠ch v·ªã tr√≠
                            
                            // L·∫•y exact context ƒë·ªÉ ph√¢n t√≠ch
                            const exactContext = texts.join(' ');
                            
                            // T√¨m pattern checkbox g·∫ßn t·ª´ n√†o h∆°n
                            const namIndex = contextText.indexOf('nam');
                            const nuIndex = contextText.indexOf('n·ªØ');
                            const totalLength = contextText.length;
                            
                            // Logic: n·∫øu checkbox ·ªü gi·ªØa "nam" v√† "n·ªØ", th√¨ c√≥ th·ªÉ l√† cho "n·ªØ"
                            if (namIndex < nuIndex) {
                                return 'N·ªØ';
                            } else {
                                return 'Nam';
                            }
                        }
                    }
                }
            }
            
            return null;
        }

        async function extractTextFromDOCX(file) {
            return new Promise((resolve, reject) => {
                const fileReader = new FileReader();
                fileReader.onload = async function() {
                    try {
                        
                        // Extract text v√† XML
                        const [textResult, zip] = await Promise.all([
                            mammoth.extractRawText({arrayBuffer: this.result}),
                            JSZip.loadAsync(this.result)
                        ]);
                        
                        const documentXml = await zip.file("word/document.xml").async("text");
                        
                        // Parse Wingdings checkbox symbols
                        const genderFromCheckbox = parseWingdingsCheckboxes(documentXml);
                        if (genderFromCheckbox) {
                            
                            // Store result globally ƒë·ªÉ s·ª≠ d·ª•ng trong analyzeCVContent
                            window.docxDetectedGender = genderFromCheckbox;
                        } else {
                        }
                        
                        // Also extract HTML for additional analysis
                        const htmlResult = await mammoth.convertToHtml({arrayBuffer: this.result});
                        
                        // Return object with text, HTML, and checkbox gender
                        resolve({
                            text: textResult.value,
                            html: htmlResult.value,
                            checkboxGender: genderFromCheckbox
                        });
                        
                    } catch (error) {
                        console.error('DOCX Wingdings parsing error:', error);
                        // Fallback to basic extraction
                        try {
                            const [textResult, htmlResult] = await Promise.all([
                                mammoth.extractRawText({arrayBuffer: this.result}),
                                mammoth.convertToHtml({arrayBuffer: this.result})
                            ]);
                            resolve({
                                text: textResult.value,
                                html: htmlResult.value,
                                checkboxGender: null
                            });
                        } catch (fallbackError) {
                            reject(fallbackError);
                        }
                    }
                };
                fileReader.onerror = () => reject(new Error('L·ªói ƒë·ªçc file DOCX'));
                fileReader.readAsArrayBuffer(file);
            });
        }



        function analyzeCVContent(text, htmlContent = null) {
            const cvInfo = {
                personal: {},
                contact: {},
                education: [],
                experience: [],
                skills: [],
                other: {},
                rawText: text // Th√™m rawText ƒë·ªÉ d√πng trong c√°c function kh√°c
            };

            // Clean and normalize text
            const cleanText = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n');

            // Extract personal information
            cvInfo.personal = extractPersonalInfo(cleanText);
            
            // Priority 1: Wingdings checkbox gender (most reliable)
            if (!cvInfo.personal.gender && window.docxDetectedGender) {
                cvInfo.personal.gender = window.docxDetectedGender;
                // Clear after use
                window.docxDetectedGender = null;
            }
            
            // Priority 2: N·∫øu kh√¥ng t√¨m th·∫•y gender t·ª´ text v√† c√≥ HTML content, th·ª≠ parse HTML
            if (!cvInfo.personal.gender && htmlContent) {
                const htmlGender = analyzeHTMLContent(htmlContent);
                if (htmlGender) {
                    cvInfo.personal.gender = htmlGender;
                }
            }
            
            // Extract contact information
            cvInfo.contact = extractContactInfo(cleanText);
            
            // Extract education
            cvInfo.education = extractEducation(cleanText);
            
            // Extract experience
            cvInfo.experience = extractExperience(cleanText);
            
            // Extract skills
            cvInfo.skills = extractSkills(cleanText);
            
            // Extract other information
            cvInfo.other = extractOtherInfo(cleanText);

            return cvInfo;
        }

        // Function ƒë·ªÉ ki·ªÉm tra xem text c√≥ ph·∫£i t√™n h·ª£p l·ªá kh√¥ng
        function isInvalidName(text) {
            const invalidKeywords = [
                'TH√îNG TIN ·ª®NG VI√äN',
                'TH√îNG TIN B·∫¢N TH√ÇN',
                'TH√îNG TIN C√Å NH√ÇN',
                'H·ªå V√Ä T√äN',
                'NG√ÄY SINH',
                'GI·ªöI T√çNH',
                'ƒê·ªäA CH·ªà',
                'S·ªê ƒêI·ªÜN THO·∫†I',
                'EMAIL',
                'H·ªåC V·∫§N',
                'KINH NGHI·ªÜM',
                'K·ª∏ NƒÇNG',
                'M·ª§C TI√äU',
                'S·ªû TH√çCH',
                'CH·ª®NG CH·ªà',
                'D√ÄNH CHO',
                'V·ªä TR√ç ·ª®NG TUY·ªÇN'
            ];
            
            const upperText = text.toUpperCase().trim();
            return invalidKeywords.some(keyword => upperText.includes(keyword));
        }

        function extractPersonalInfo(text) {
            const personal = {};
            const lines = text.split('\n').map(line => line.trim()).filter(line => line);
            

            lines.forEach((line, index) => {
            });
            
            // T√¨m t√™n theo c·∫•u tr√∫c kh√°c nhau c·ªßa DOCX v√† PDF
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                
                // Case 1: PDF - T√™n trong c√πng d√≤ng "H·ªç v√† t√™n (ch·ªØ in hoa) PH·∫†M Y·∫æN LINH"
                if (/h·ªç\s*v√†\s*t√™n.*ch·ªØ\s*in\s*hoa/i.test(line)) {
                    
                    const nameInLinePattern = /h·ªç\s*v√†\s*t√™n.*?ch·ªØ\s*in\s*hoa\s*([A-Z√Å√Ä·∫¢√É·∫†ƒÇ·∫Æ·∫∞·∫≤·∫¥·∫∂√Ç·∫§·∫¶·∫®·∫™·∫¨ƒê√â√à·∫∫·∫º·∫∏√ä·∫æ·ªÄ·ªÇ·ªÑ·ªÜ√ç√å·ªàƒ®·ªä√ì√í·ªé√ï·ªå√î·ªê·ªí·ªî·ªñ·ªò∆†·ªö·ªú·ªû·ª†·ª¢√ö√ô·ª¶≈®·ª§∆Ø·ª®·ª™·ª¨·ªÆ·ª∞√ù·ª≤·ª∂·ª∏·ª¥][A-Z√Å√Ä·∫¢√É·∫†ƒÇ·∫Æ·∫∞·∫≤·∫¥·∫∂√Ç·∫§·∫¶·∫®·∫™·∫¨ƒê√â√à·∫∫·∫º·∫∏√ä·∫æ·ªÄ·ªÇ·ªÑ·ªÜ√ç√å·ªàƒ®·ªä√ì√í·ªé√ï·ªå√î·ªê·ªí·ªî·ªñ·ªò∆†·ªö·ªú·ªû·ª†·ª¢√ö√ô·ª¶≈®·ª§∆Ø·ª®·ª™·ª¨·ªÆ·ª∞√ù·ª≤·ª∂·ª∏·ª¥\s]+?)(?:\s*ng√†y|\s*$)/i;
                    const inLineMatch = line.match(nameInLinePattern);
                    if (inLineMatch) {
                        const candidateName = inLineMatch[1].trim();
                        
                        if (!isInvalidName(candidateName)) {
                            personal.name = candidateName;
                            break;
                        }
                    }
                    
                    // Case 2: DOCX - D√≤ng "H·ªç v√† t√™n (ch·ªØ in hoa)" ri√™ng bi·ªát
                    if (/h·ªç\s*v√†\s*t√™n.*ch·ªØ\s*in\s*hoa\s*$/i.test(line)) {
                        // T√¨m t√™n trong c√°c d√≤ng ti·∫øp theo cho ƒë·∫øn khi g·∫∑p "Ng√†y sinh"
                        for (let j = i + 1; j < Math.min(i + 5, lines.length); j++) {
                            const nextLine = lines[j].trim();
                            
                            // N·∫øu g·∫∑p d√≤ng "Ng√†y sinh" th√¨ d·ª´ng
                            if (/^ng√†y\s*sinh/i.test(nextLine)) {
                                break;
                            }
                            
                            // T√¨m t√™n ƒë·∫ßy ƒë·ªß (ch·ªØ in hoa ti·∫øng Vi·ªát, ƒë·ªô d√†i h·ª£p l√Ω) v√† kh√¥ng ph·∫£i t·ª´ kh√≥a
                            if (/^[A-Z√Å√Ä·∫¢√É·∫†ƒÇ·∫Æ·∫∞·∫≤·∫¥·∫∂√Ç·∫§·∫¶·∫®·∫™·∫¨ƒê√â√à·∫∫·∫º·∫∏√ä·∫æ·ªÄ·ªÇ·ªÑ·ªÜ√ç√å·ªàƒ®·ªä√ì√í·ªé√ï·ªå√î·ªê·ªí·ªî·ªñ·ªò∆†·ªö·ªú·ªû·ª†·ª¢√ö√ô·ª¶≈®·ª§∆Ø·ª®·ª™·ª¨·ªÆ·ª∞√ù·ª≤·ª∂·ª∏·ª¥][A-Z√Å√Ä·∫¢√É·∫†ƒÇ·∫Æ·∫∞·∫≤·∫¥·∫∂√Ç·∫§·∫¶·∫®·∫™·∫¨ƒê√â√à·∫∫·∫º·∫∏√ä·∫æ·ªÄ·ªÇ·ªÑ·ªÜ√ç√å·ªàƒ®·ªä√ì√í·ªé√ï·ªå√î·ªê·ªí·ªî·ªñ·ªò∆†·ªö·ªú·ªû·ª†·ª¢√ö√ô·ª¶≈®·ª§∆Ø·ª®·ª™·ª¨·ªÆ·ª∞√ù·ª≤·ª∂·ª∏·ª¥\s]{8,50}$/i.test(nextLine) && !isInvalidName(nextLine)) {
                                personal.name = nextLine.trim();
                                break;
                            } else {
                            }
                        }
                        if (personal.name) break;
                    }
                }
                
                // Pattern ƒë·∫∑c bi·ªát: T√¨m t√™n PH·∫†M Y·∫æN LINH trong d√≤ng ri√™ng bi·ªát
                if (/^PH·∫†M\s*Y·∫æN\s*LINH$/i.test(line)) {
                    personal.name = line.trim();
                    break;
                }
                
                // Pattern ƒë∆°n gi·∫£n: T√¨m t√™n h·ªç ch·ªâ c√≥ ch·ªØ in hoa v√† kho·∫£ng tr·∫Øng
                if (/^[A-Z√Å√Ä·∫¢√É·∫†ƒÇ·∫Æ·∫∞·∫≤·∫¥·∫∂√Ç·∫§·∫¶·∫®·∫™·∫¨ƒê√â√à·∫∫·∫º·∫∏√ä·∫æ·ªÄ·ªÇ·ªÑ·ªÜ√ç√å·ªàƒ®·ªä√ì√í·ªé√ï·ªå√î·ªê·ªí·ªî·ªñ·ªò∆†·ªö·ªú·ªû·ª†·ª¢√ö√ô·ª¶≈®·ª§∆Ø·ª®·ª™·ª¨·ªÆ·ª∞√ù·ª≤·ª∂·ª∏·ª¥\s]+$/.test(line) && 
                    line.length >= 10 && line.length <= 50 && 
                    !isInvalidName(line) &&
                    line.split(' ').length >= 2 && line.split(' ').length <= 5) {
                    personal.name = line.trim();
                    break;
                }
            }
            
            
            // N·∫øu v·∫´n ch∆∞a t√¨m th·∫•y t√™n, th·ª≠ pattern d·ª± ph√≤ng
            if (!personal.name) {
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    
                    // C√°c pattern d·ª± ph√≤ng kh√°c
                    const alternativePatterns = [
                        /(?:h·ªç t√™n|h·ªç v√† t√™n|t√™n|name)[:\s]*([A-Z√Å√Ä·∫¢√É·∫†ƒÇ·∫Æ·∫∞·∫≤·∫¥·∫∂√Ç·∫§·∫¶·∫®·∫™·∫¨ƒê√â√à·∫∫·∫º·∫∏√ä·∫æ·ªÄ·ªÇ·ªÑ·ªÜ√ç√å·ªàƒ®·ªä√ì√í·ªé√ï·ªå√î·ªê·ªí·ªî·ªñ·ªò∆†·ªö·ªú·ªû·ª†·ª¢√ö√ô·ª¶≈®·ª§∆Ø·ª®·ª™·ª¨·ªÆ·ª∞√ù·ª≤·ª∂·ª∏·ª¥][a-zA-Z√Å√Ä·∫¢√É·∫†ƒÇ·∫Æ·∫∞·∫≤·∫¥·∫∂√Ç·∫§·∫¶·∫®·∫™·∫¨ƒê√â√à·∫∫·∫º·∫∏√ä·∫æ·ªÄ·ªÇ·ªÑ·ªÜ√ç√å·ªàƒ®·ªä√ì√í·ªé√ï·ªå√î·ªê·ªí·ªî·ªñ·ªò∆†·ªö·ªú·ªû·ª†·ª¢√ö√ô·ª¶≈®·ª§∆Ø·ª®·ª™·ª¨·ªÆ·ª∞√ù·ª≤·ª∂·ª∏·ª¥\s]+)/i
                    ];
                    
                    for (const pattern of alternativePatterns) {
                        const altMatch = line.match(pattern);
                        if (altMatch) {
                            const candidateName = altMatch[1] ? altMatch[1].trim() : altMatch[0].trim();
                            if (!isInvalidName(candidateName)) {
                                personal.name = candidateName;
                                break;
                            }
                        }
                    }
                    if (personal.name) break;
                }
            }
            
            // T√¨m ng√†y sinh theo c·∫•u tr√∫c kh√°c nhau c·ªßa DOCX v√† PDF
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                
                // Case 1: PDF - "Ng√†y sinh 23/11/2003 N∆°i sinh H√Ä N·ªòI"
                const pdfDobPattern = /ng√†y\s*sinh\s*(\d{1,2}\/\d{1,2}\/\d{4})/i;
                const pdfDobMatch = line.match(pdfDobPattern);
                if (pdfDobMatch) {
                    personal.dateOfBirth = pdfDobMatch[1];
                    break;
                }
                
                // Case 2: DOCX - D√≤ng ri√™ng bi·ªát "Ng√†y sinh" r·ªìi ng√†y ·ªü d√≤ng ti·∫øp theo
                if (/^ng√†y\s*sinh\s*$/i.test(line)) {
                    // T√¨m ng√†y sinh trong d√≤ng ti·∫øp theo
                    if (i + 1 < lines.length) {
                        const nextLine = lines[i + 1];
                        const docxDobMatch = nextLine.match(/(\d{1,2}\/\d{1,2}\/\d{4})/);
                        if (docxDobMatch) {
                            personal.dateOfBirth = docxDobMatch[1];
                            break;
                        }
                    }
                }
                
                // Pattern d·ª± ph√≤ng: t√¨m ng√†y sinh trong c√πng d√≤ng v·ªõi t√™n
                const dobInLinePattern = /ng√†y\s*sinh\s*(\d{1,2}\/\d{1,2}\/\d{4})/i;
                const dobInLineMatch = line.match(dobInLinePattern);
                if (dobInLineMatch) {
                    personal.dateOfBirth = dobInLineMatch[1];
                    break;
                }
                
                // T√¨m ng√†y sinh sau t√™n (PDF c√≥ th·ªÉ t√°ch ri√™ng)
                if (personal.name && line.includes(personal.name)) {
                    // T√¨m ng√†y sinh trong c√πng d√≤ng v·ªõi t√™n
                    const dobAfterName = line.match(/(?:ng√†y|Ng√†y).*?(\d{1,2}\/\d{1,2}\/\d{4})/i);
                    if (dobAfterName) {
                        personal.dateOfBirth = dobAfterName[1];
                        break;
                    }
                    
                    // T√¨m trong c√°c d√≤ng ti·∫øp theo
                    for (let j = i + 1; j < Math.min(i + 3, lines.length); j++) {
                        const nextLine = lines[j];
                        const dobNext = nextLine.match(/(\d{1,2}\/\d{1,2}\/\d{4})/);
                        if (dobNext) {
                            personal.dateOfBirth = dobNext[1];
                            break;
                        }
                    }
                    if (personal.dateOfBirth) break;
                }
                
                // T√¨m ng√†y sinh trong d√≤ng hi·ªán t·∫°i v·ªõi c√°c pattern kh√°c
                const dobMatch = line.match(/(?:ng√†y sinh|sinh)[:\s]*(\d{1,2}\/\d{1,2}\/\d{4})|^(\d{1,2}\/\d{1,2}\/\d{4})$/i);
                if (dobMatch) {
                    personal.dateOfBirth = dobMatch[1] || dobMatch[2];
                    break;
                }
            }
            

            
            // T√¨m gi·ªõi t√≠nh v·ªõi nhi·ªÅu pattern bao g·ªìm checkbox
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                
                // Case 1: Enhanced checkbox patterns v·ªõi Word symbols
                const checkboxSymbols = ['‚òê', '‚òë', '‚úì', '‚úî', '‚úó', '‚úò', '‚ñ°', '‚ñ†', '‚ñ¢', '‚ñ£', '√æ', '‚óØ', '‚óè', '‚óã', '‚óâ', '‚àÖ', '‚äó', '‚äï', 'xX'];
                const checkedSymbols = ['‚òë', '‚úì', '‚úî', '‚ñ†', '‚ñ£', '√æ', '‚óè', '‚óâ', '‚äó', '‚äï', 'xX'];
                
                const checkboxPatterns = [
                    // Expanded symbol patterns
                    new RegExp(`[${checkedSymbols.join('')}]\\s*(nam|n·ªØ)`, 'i'),
                    new RegExp(`(nam|n·ªØ)\\s*[${checkedSymbols.join('')}]`, 'i'),
                    
                    // Specific Word symbols
                    /[‚ñ†‚óè‚óâ‚äó‚äï]\s*(nam|n·ªØ)/i,
                    /(nam|n·ªØ)\s*[‚ñ†‚óè‚óâ‚äó‚äï]/i,
                    
                    // Empty vs filled patterns
                    /[‚òê‚ñ°‚óã‚óØ]\s*nam[^‚ñ†‚óè‚óâ‚äó‚äï]*[‚ñ†‚óè‚óâ‚äó‚äï]\s*n·ªØ/i,
                    /[‚òê‚ñ°‚óã‚óØ]\s*n·ªØ[^‚ñ†‚óè‚óâ‚äó‚äï]*[‚ñ†‚óè‚óâ‚äó‚äï]\s*nam/i,
                    /[‚ñ†‚óè‚óâ‚äó‚äï]\s*nam[^‚ñ†‚óè‚óâ‚äó‚äï]*[‚òê‚ñ°‚óã‚óØ]\s*n·ªØ/i,
                    /[‚ñ†‚óè‚óâ‚äó‚äï]\s*n·ªØ[^‚ñ†‚óè‚óâ‚äó‚äï]*[‚òê‚ñ°‚óã‚óØ]\s*nam/i,
                    
                    // Pattern "Gi·ªõi t√≠nh" v·ªõi symbols
                    new RegExp(`gi·ªõi\\s*t√≠nh[:\\s]*[${checkboxSymbols.join('')}\\s]*(nam|n·ªØ)[${checkboxSymbols.join('')}\\s]*(nam|n·ªØ)`, 'i')
                ];
                
                for (let p = 0; p < checkboxPatterns.length; p++) {
                    const pattern = checkboxPatterns[p];
                    const match = line.match(pattern);
                    if (match) {
                        
                        // X√°c ƒë·ªãnh gi√° tr·ªã ƒë∆∞·ª£c ch·ªçn d·ª±a tr√™n symbol
                        const fullMatch = match[0];
                        const hasCheckedSymbolWithNam = new RegExp(`[${checkedSymbols.join('')}].*nam`, 'i').test(fullMatch);
                        const hasCheckedSymbolWithNu = new RegExp(`[${checkedSymbols.join('')}].*n·ªØ`, 'i').test(fullMatch);
                        const hasNamWithCheckedSymbol = new RegExp(`nam.*[${checkedSymbols.join('')}]`, 'i').test(fullMatch);
                        const hasNuWithCheckedSymbol = new RegExp(`n·ªØ.*[${checkedSymbols.join('')}]`, 'i').test(fullMatch);
                        
                        if ((hasCheckedSymbolWithNam || hasNamWithCheckedSymbol) && !(hasCheckedSymbolWithNu || hasNuWithCheckedSymbol)) {
                            personal.gender = 'Nam';
                            break;
                        } else if ((hasCheckedSymbolWithNu || hasNuWithCheckedSymbol) && !(hasCheckedSymbolWithNam || hasNamWithCheckedSymbol)) {
                            personal.gender = 'N·ªØ';
                            break;
                        }
                    }
                }
                
                if (personal.gender) break;
                
                // Case 1.5: Check if c√≥ symbols trong d√≤ng hi·ªán t·∫°i v√† gender trong d√≤ng g·∫ßn ƒë√≥
                const hasAnySymbol = checkboxSymbols.some(symbol => line.includes(symbol));
                if (hasAnySymbol && /gi·ªõi|t√≠nh/i.test(line)) {
                    
                    // Ki·ªÉm tra 3 d√≤ng ti·∫øp theo
                    for (let nextIdx = i + 1; nextIdx < Math.min(i + 4, lines.length); nextIdx++) {
                        const nextLine = lines[nextIdx];
                        
                        // T√¨m checked symbols trong d√≤ng n√†y
                        const checkedSymbolsInLine = checkedSymbols.filter(symbol => nextLine.includes(symbol));
                        if (checkedSymbolsInLine.length > 0) {
                            
                            if (/nam/i.test(nextLine) && !/n·ªØ/i.test(nextLine)) {
                                personal.gender = 'Nam';
                                break;
                            } else if (/n·ªØ/i.test(nextLine) && !/nam/i.test(nextLine)) {
                                personal.gender = 'N·ªØ';
                                break;
                            }
                        }
                    }
                    
                    if (personal.gender) break;
                }
                
                // Case 2: DOCX patterns - kh√¥ng c√≥ checkbox symbols
                if (/gi·ªõi\s*t√≠nh/i.test(line)) {
                    
                    // T√¨m gi·ªõi t√≠nh trong c√πng d√≤ng
                    const sameLine = line.match(/gi·ªõi\s*t√≠nh[:\s]*(nam|n·ªØ)/i);
                    if (sameLine) {
                        personal.gender = sameLine[1];
                        break;
                    }
                    
                    // T√¨m trong d√≤ng ti·∫øp theo
                    if (i + 1 < lines.length) {
                        const nextLine = lines[i + 1].trim();
                        if (/^(nam|n·ªØ)$/i.test(nextLine)) {
                            personal.gender = nextLine;
                            break;
                        }
                    }
                    
                    // DOCX: Ki·ªÉm tra pattern nhi·ªÅu d√≤ng v·ªõi Nam/N·ªØ
                    for (let j = i; j < Math.min(i + 5, lines.length); j++) {
                        const checkLine = lines[j];
                        
                        // Ki·ªÉm tra n·∫øu l√† d√≤ng c√≥ t·∫•t c·∫£ options (Nam N·ªØ Kh√°c)
                        if (/nam.*n·ªØ.*kh√°c/i.test(checkLine) || /nam\s+n·ªØ/i.test(checkLine)) {
                            
                            // Th·ª≠ ph√¢n t√≠ch spacing ƒë·ªÉ detect selection
                            const genderFromSpacing = analyzeSpacingForSelection(checkLine);
                            if (genderFromSpacing) {
                                personal.gender = genderFromSpacing;
                                break;
                            } else {
                                personal.gender = 'KH√îNG X√ÅC ƒê·ªäNH ƒê∆Ø·ª¢C - T·ª∞ ƒêI·ªÄN ƒêI BRO';
                                break;
                            }
                        }
                        // Ch·ªâ accept "Nam" ho·∫∑c "N·ªØ" n·∫øu ch√∫ng ƒë·ª©ng HO√ÄN TO√ÄN m·ªôt m√¨nh
                        else if (/^nam$/i.test(checkLine.trim())) {
                            personal.gender = 'Nam';
                            break;
                        } else if (/^n·ªØ$/i.test(checkLine.trim())) {
                            personal.gender = 'N·ªØ';
                            break;
                        }
                    }
                    
                    if (personal.gender) break;
                }
                
                // Case 3: T√¨m gi·ªõi t√≠nh g·∫ßn ng√†y sinh
                if (personal.dateOfBirth && line.includes(personal.dateOfBirth)) {
                    const genderNearDate = line.match(/\d{1,2}\/\d{1,2}\/\d{4}\s*(nam|n·ªØ)/i);
                    if (genderNearDate) {
                        personal.gender = genderNearDate[1];
                        break;
                    }
                }
                
                // Case 4: Table structure pattern - t√¨m trong c·∫•u tr√∫c b·∫£ng CV
                const tablePatterns = [
                    // Pattern: | Gi·ªõi t√≠nh | Nam | ho·∫∑c t∆∞∆°ng t·ª±
                    /\|\s*gi·ªõi\s*t√≠nh\s*\|\s*(nam|n·ªØ)\s*\|/i,
                    /gi·ªõi\s*t√≠nh\s*:\s*(nam|n·ªØ)/i,
                    /gi·ªõi\s*t√≠nh\s*-\s*(nam|n·ªØ)/i,
                    /gi·ªõi\s*t√≠nh\s+\|\s*(nam|n·ªØ)/i
                ];
                
                for (const tablePattern of tablePatterns) {
                    const tableMatch = line.match(tablePattern);
                    if (tableMatch) {
                        personal.gender = tableMatch[1];
                        break;
                    }
                }
                
                if (personal.gender) break;
            }
            
            // Final fallback - search for any gender keywords
            if (!personal.gender) {
                const fullText = text.toLowerCase();
                if (fullText.includes('nam') && !fullText.includes('n·ªØ')) {
                    personal.gender = 'Nam';
                } else if (fullText.includes('n·ªØ') && !fullText.includes('nam')) {
                    personal.gender = 'N·ªØ';
                } else if (fullText.includes('nam') && fullText.includes('n·ªØ')) {
                } else {
                }
            }
            
            return personal;
        }

        function extractContactInfo(text) {
            const contact = {};
            const lines = text.split('\n').map(line => line.trim()).filter(line => line);
            
            // T√¨m email sau ti√™u ƒë·ªÅ ho·∫∑c trong text
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                
                // Ki·ªÉm tra ti√™u ƒë·ªÅ email
                if (/^(email|mail|e-mail)$/i.test(line)) {
                    if (i + 1 < lines.length) {
                        const nextLine = lines[i + 1];
                        const emailMatch = nextLine.match(/([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})/);
                        if (emailMatch) {
                            contact.email = emailMatch[1];
                            break;
                        }
                    }
                }
                
                // T√¨m email trong d√≤ng hi·ªán t·∫°i
                const emailMatch = line.match(/([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})/);
                if (emailMatch) {
                    contact.email = emailMatch[1];
                    break;
                }
            }
            
            // T√¨m s·ªë ƒëi·ªán tho·∫°i ch·ªâ sau ch·ªØ "ƒêi·ªán tho·∫°i"
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                
                if (/ƒëi·ªán\s*tho·∫°i/i.test(line)) {
                    
                    // T√¨m s·ªë trong c√πng d√≤ng sau t·ª´ "ƒëi·ªán tho·∫°i"
                    const sameLineMatch = line.match(/ƒëi·ªán\s*tho·∫°i[:\s]*([0-9]+)/i);
                    if (sameLineMatch) {
                        contact.phone = sameLineMatch[1];
                        break;
                    }
                    
                    // T√¨m s·ªë trong d√≤ng k·∫ø ti·∫øp
                    if (i + 1 < lines.length) {
                        const nextLine = lines[i + 1];
                        const phoneMatch = nextLine.match(/^([0-9]+)/);
                        if (phoneMatch) {
                            contact.phone = phoneMatch[1];
                            break;
                        }
                    }
                }
            }

            return contact;
        }

        function extractEducation(text) {
            const educationSectionMatch = text.match(/QU√Å\s*TR√åNH\s*H·ªåC\s*T·∫¨P(.*?)QU√Å\s*TR√åNH\s*C√îNG\s*T√ÅC/is);
            
            if (!educationSectionMatch) {
                return [];
            }
            
            const educationSection = educationSectionMatch[1].trim();
            const lines = educationSection.split('\n').map(line => line.trim()).filter(line => line);
            const education = [];
            
            for (const line of lines) {
                if (!line || line.length < 3) continue;
                
                let educationType = '';
                const lineLower = line.toLowerCase();
                
                if (lineLower.includes('cao h·ªçc') || lineLower.includes('th·∫°c sƒ©') || lineLower.includes('master')) {
                    educationType = 'Cao h·ªçc';
                } else if (lineLower.includes('ƒë·∫°i h·ªçc') || lineLower.includes('c·ª≠ nh√¢n') || lineLower.includes('bachelor') || 
                          lineLower.includes('university') || lineLower.includes('college')) {
                    educationType = 'ƒê·∫°i h·ªçc';
                } else if (lineLower.includes('ti·∫øn sƒ©') || lineLower.includes('phd') || lineLower.includes('doctorate')) {
                    educationType = 'Ti·∫øn sƒ©';
                } else {
                    educationType = 'ƒê·∫°i h·ªçc';
                }
                
                const educationEntry = {
                    level: educationType,
                    details: line,
                    raw: line
                };
                
                education.push(educationEntry);
            }
            
            return education;
        }

        function extractExperience(text) {
            const experienceMatch = text.match(/QU√Å\s*TR√åNH\s*C√îNG\s*T√ÅC(.*?)(?=V·ªä\s*TR√ç\s*·ª®NG\s*TUY·ªÇN|$)/is);
            
            if (!experienceMatch) {
                const experience = [];
                const lines = text.split('\n').map(line => line.trim()).filter(line => line);
                
                for (const line of lines) {
                    const expPattern = /(\d{1,2}\/20\d{2})\s*-\s*(\d{1,2}\/20\d{2}|nay|hi·ªán t·∫°i)[:\s]*([^\n]+)/i;
                    const match = line.match(expPattern);
                    
                    if (match) {
                        const timeRange = `${match[1]} - ${match[2]}`;
                        const description = match[3].trim();
                        
                        experience.push({
                            timeRange,
                            description,
                            raw: line,
                            isCurrent: /nay|hi·ªán t·∫°i/i.test(match[2])
                        });
                    }
                }
                
                return experience;
            }
            
            const experienceSection = experienceMatch[1].trim();
            const lines = experienceSection.split('\n').map(line => line.trim()).filter(line => line);
            const experience = [];
            
            for (const line of lines) {
                if (!line || line.length < 5) continue;
                
                const expPattern = /(\d{1,2}\/20\d{2})\s*-\s*(\d{1,2}\/20\d{2}|nay|hi·ªán t·∫°i)[:\s]*(.+)/i;
                const match = line.match(expPattern);
                
                if (match) {
                    const timeRange = `${match[1]} - ${match[2]}`;
                    const description = match[3].trim();
                    const isCurrent = /nay|hi·ªán t·∫°i/i.test(match[2]);
                    
                    let position = '';
                    let company = '';
                    
                    const posCompanyMatch = description.match(/^([^-]+?)\s*[-‚Äì‚Äî]\s*(.+)$/);
                    if (posCompanyMatch) {
                        position = posCompanyMatch[1].trim();
                        company = posCompanyMatch[2].trim();
                    } else {
                        position = description;
                    }
                    
                    const experienceEntry = {
                        timeRange,
                        position,
                        company,
                        description,
                        raw: line,
                        isCurrent
                    };
                    
                    experience.push(experienceEntry);
                }
            }
            
            return experience;
        }

        function extractSkills(text) {
            const skills = [];
            const skillKeywords = ['k·ªπ nƒÉng', 'skills', 'technical', 'programming', 'ng√¥n ng·ªØ'];
            
            // Common technical skills
            const techSkills = [
                'JavaScript', 'Python', 'Java', 'C++', 'C#', 'PHP', 'Ruby', 'Go', 'Swift',
                'HTML', 'CSS', 'React', 'Angular', 'Vue', 'Node.js', 'Express',
                'MySQL', 'PostgreSQL', 'MongoDB', 'Redis',
                'Git', 'Docker', 'Kubernetes', 'AWS', 'Azure',
                'Photoshop', 'Illustrator', 'Figma', 'Sketch'
            ];
            
            techSkills.forEach(skill => {
                if (text.toLowerCase().includes(skill.toLowerCase())) {
                    skills.push(skill);
                }
            });
            
            // Language skills
            const languages = ['English', 'Ti·∫øng Anh', 'Chinese', 'Ti·∫øng Trung', 'Japanese', 'Ti·∫øng Nh·∫≠t'];
            languages.forEach(lang => {
                if (text.toLowerCase().includes(lang.toLowerCase())) {
                    skills.push(lang);
                }
            });
            
            return [...new Set(skills)]; // Remove duplicates
        }

        function extractOtherInfo(text) {
            const other = {};
            
            // Objective/Summary
            const objectiveMatch = text.match(/(?:m·ª•c ti√™u|objective|summary|t√≥m t·∫Øt)[:\s]*([^\n]{20,200})/i);
            if (objectiveMatch) {
                other.objective = objectiveMatch[1].trim();
            }
            
            // Hobbies
            const hobbiesMatch = text.match(/(?:s·ªü th√≠ch|hobbies|interests)[:\s]*([^\n]{10,100})/i);
            if (hobbiesMatch) {
                other.hobbies = hobbiesMatch[1].trim();
            }
            
            // References
            if (text.toLowerCase().includes('reference') || text.toLowerCase().includes('ng∆∞·ªùi gi·ªõi thi·ªáu')) {
                other.hasReferences = true;
            }
            
            return other;
        }

        // Danh s√°ch l∆∞u tr·ªØ CV
        let cvList = JSON.parse(localStorage.getItem('cvList') || '[]');
        let currentCV = null;

        function displayResults(cvInfo, rawText) {
            currentCV = extractTableRow(cvInfo);
            renderTable();
            
            document.getElementById('rawContent').textContent = rawText.substring(0, 2000) + (rawText.length > 2000 ? '\n... (n·ªôi dung ƒë√£ ƒë∆∞·ª£c c·∫Øt b·ªõt)' : '');
            resultsSection.style.display = 'block';
            resultsSection.scrollIntoView({ behavior: 'smooth' });
        }

        function extractTableRow(cvInfo) {
            return {
                name: (cvInfo.personal.name || '').toUpperCase(),
                title: guessTitle(cvInfo),
                mail: cvInfo.contact.email || '',
                phone: cvInfo.contact.phone || '',
                dob: cvInfo.personal.dateOfBirth || '',
                gender: cvInfo.personal.gender || '',
                education: guessEducationLevel(cvInfo),
                school: guessSchool(cvInfo),
                major: guessMajor(cvInfo),
                currentPosition: guessCurrentPosition(cvInfo),
                experience: guessExperience(cvInfo),
                appliedPosition: guessAppliedPosition(cvInfo)
            };
        }

        function guessTitle(cvInfo) {
            // D·ª±a v√†o gi·ªõi t√≠nh ƒë·ªÉ x√°c ƒë·ªãnh title
            const gender = (cvInfo.personal.gender || '').toLowerCase();
            if (gender.includes('nam') || gender.includes('male')) return '√îNG';
            if (gender.includes('n·ªØ') || gender.includes('female')) return 'B√Ä';
            return '';
        }
        
        function guessEducationLevel(cvInfo) {
            if (Array.isArray(cvInfo.education) && cvInfo.education.length > 0) {
                const firstEntry = cvInfo.education[0];
                if (typeof firstEntry === 'object' && firstEntry.level) {
                    return firstEntry.level;
                }
            }
            
            const eduText = Array.isArray(cvInfo.education) ? 
                cvInfo.education.join(' ').toLowerCase() : 
                (cvInfo.education || '').toLowerCase();
                
            if (eduText.includes('cao h·ªçc') || eduText.includes('master') || eduText.includes('th·∫°c sƒ©')) {
                return 'Cao h·ªçc';
            }
            if (eduText.includes('ƒë·∫°i h·ªçc') || eduText.includes('university') || eduText.includes('bachelor')) {
                return 'ƒê·∫°i h·ªçc';
            }
            if (eduText.includes('cao ƒë·∫≥ng') || eduText.includes('college')) {
                return 'Cao ƒë·∫≥ng';
            }
            
            return '';
        }
        
        function guessSchool(cvInfo) {
            for (const edu of cvInfo.education) {
                const eduText = typeof edu === 'object' ? edu.details : edu;
                
                const schoolMatch = eduText.match(/(ƒê·∫°i h·ªçc [^-]+|[A-Z][a-z\s]+ University|FPT [^-]+)/i);
                if (schoolMatch) {
                    return schoolMatch[1].trim();
                }
            }
            return '';
        }
        
        function guessMajor(cvInfo) {
            for (const edu of cvInfo.education) {
                const eduText = typeof edu === 'object' ? edu.details : edu;
                
                const majorMatch = eduText.match(/-\s*([^\n]+)$/);
                if (majorMatch) {
                    return majorMatch[1].trim();
                }
                
                if (eduText.toLowerCase().includes('digital marketing')) {
                    return 'Digital Marketing';
                }
            }
            return '';
        }
        
        function guessCurrentPosition(cvInfo) {
            if (!Array.isArray(cvInfo.experience) || cvInfo.experience.length === 0) {
                return '';
            }
            
            let currentPosition = '';
            let structuredExperiences = cvInfo.experience.filter(exp => 
                typeof exp === 'object' && exp !== null && exp.timeRange
            );
            
            
            if (structuredExperiences.length > 0) {
                structuredExperiences.sort((a, b) => {
                    const getStartTime = (exp) => {
                        const match = exp.timeRange.match(/(\d{1,2})\/(\d{4})/);
                        if (match) {
                            const year = parseInt(match[2]);
                            const month = parseInt(match[1]);
                            return year * 12 + month;
                        }
                        return 0;
                    };
                    return getStartTime(b) - getStartTime(a);
                });
                
                const latestJob = structuredExperiences[0];
                
                if (latestJob && (latestJob.isCurrent === true || 
                    String(latestJob.isCurrent).toLowerCase() === 'true' || 
                    /nay|hi·ªán t·∫°i/i.test(latestJob.timeRange))) {
                    currentPosition = latestJob.position || 
                                    (latestJob.description ? latestJob.description.split('-')[0].trim() : '');
                }
            }
            
            // Fallback: parse t·ª´ experience text (old format)
            if (!currentPosition) {
                for (const exp of cvInfo.experience) {
                    const expText = typeof exp === 'object' ? exp.raw || exp.description : exp;
                    
                    if (/nay|hi·ªán t·∫°i|present|current/i.test(expText)) {
                        
                        // Pattern ƒë·ªÉ t√¨m v·ªã tr√≠ trong format "time: position - company"
                        const positionMatch = expText.match(/(?:\d+\/\d+\s*-\s*(?:nay|hi·ªán t·∫°i)[:\s]*([^-]+?)(?:\s*-|$))/i) ||
                                           expText.match(/[:\s]+([^-]+?)\s*-/);
                        
                        if (positionMatch) {
                            currentPosition = positionMatch[1].trim();
                            break;
                        }
                    }
                }
            }
            
            if (!currentPosition) {
            }
            
            return currentPosition;
        }
        
        function guessExperience(cvInfo) {
            
            if (!Array.isArray(cvInfo.experience) || cvInfo.experience.length === 0) {
                return '';
            }
            
            const formattedExperience = [];
            
            cvInfo.experience.forEach((exp, idx) => {
                
                if (typeof exp === 'object' && exp !== null && exp.timeRange) {
                    
                    // Format: "MM/YYYY - MM/YYYY: V·ªã tr√≠ - C√¥ng ty" ho·∫∑c fallback to description
                    const timeRange = exp.timeRange || 'Unknown Time';
                    let formatted = '';
                    
                    if (exp.position && exp.company) {
                        formatted = `${timeRange}: ${exp.position} - ${exp.company}`;
                    } else if (exp.position) {
                        formatted = `${timeRange}: ${exp.position}`;
                    } else if (exp.description) {
                        formatted = `${timeRange}: ${exp.description}`;
                    } else {
                        formatted = `${timeRange}: Unknown Position`;
                    }
                    
                    formattedExperience.push(formatted);
                } else {
                    const expText = typeof exp === 'string' ? exp : 
                                  (exp && exp.raw) ? exp.raw : 
                                  (exp && exp.description) ? exp.description : 
                                  String(exp);
                    
                    if (expText && expText.trim() && expText.trim() !== 'null' && expText.trim() !== 'undefined') {
                        formattedExperience.push(expText.trim());
                    }
                }
            });
            
            return formattedExperience.join('\n');
        }
        
        function guessAppliedPosition(cvInfo) {
            const text = cvInfo.rawText || '';
            
            // T√¨m ƒëo·∫°n t·ª´ "N∆°i l√†m vi·ªác" ƒë·∫øn "TH√îNG TIN B·∫¢N TH√ÇN"
            const startPattern = /n∆°i\s*l√†m\s*vi·ªác/i;
            const endPattern = /th√¥ng\s*tin\s*b·∫£n\s*th√¢n/i;
            
            const startMatch = text.search(startPattern);
            const endMatch = text.search(endPattern);
            
            if (startMatch === -1) {
                return '';
            }
            
            // L·∫•y ƒëo·∫°n text t·ª´ sau "N∆°i l√†m vi·ªác" ƒë·∫øn tr∆∞·ªõc "TH√îNG TIN B·∫¢N TH√ÇN"
            const startIndex = startMatch + text.match(startPattern)[0].length;
            const endIndex = endMatch !== -1 ? endMatch : text.length;
            const sectionText = text.substring(startIndex, endIndex).trim();
            
            if (!sectionText) {
                return '';
            }
            
            // T√°ch th√†nh c√°c d√≤ng v√† l·ªçc b·ªè d√≤ng tr·ªëng
            const lines = sectionText.split('\n')
                .map(line => line.trim())
                .filter(line => line.length > 0);
            
            const positions = [];
            
            lines.forEach((line, index) => {
                // B·ªè qua c√°c d√≤ng kh√¥ng li√™n quan
                if (/^(n∆°i\s*l√†m\s*vi·ªác|ƒë·ªãa\s*ch·ªâ|location|v·ªã\s*tr√≠\s*·ª©ng\s*tuy·ªÉn)$/i.test(line)) {
                    return;
                }
                
                // B·ªè qua d√≤ng ch·ªâ c√≥ k√Ω t·ª± ƒë·∫∑c bi·ªát ho·∫∑c qu√° ng·∫Øn
                if (line.length < 3 || /^[\s\-_=\.:\|]+$/.test(line)) {
                    return;
                }
                
                // Ki·ªÉm tra xem d√≤ng c√≥ ph·∫£i l√† v·ªã tr√≠ ·ª©ng tuy·ªÉn kh√¥ng
                if (line.length >= 3) {
                    // N·∫øu d√≤ng ƒë√£ c√≥ s·ªë th·ª© t·ª± th√¨ gi·ªØ nguy√™n
                    if (/^\d+\.\s/.test(line)) {
                        positions.push(line);
                    } else {
                        // N·∫øu ch∆∞a c√≥ s·ªë th·ª© t·ª± th√¨ th√™m v√†o
                        positions.push(`${positions.length + 1}. ${line}`);
                    }
                }
            });
            
            return positions.join(' ');
        }

        function renderTable() {
            const body = document.getElementById('resultsBody');
            if (!body) return; // Safety check
            body.innerHTML = '';
            let allCVs = [...cvList];
            if (currentCV) allCVs.push(currentCV);
            allCVs.forEach((cv, idx) => {
                body.innerHTML += `<tr>
                    <td>${idx + 1}</td>
                    <td>${cv.name}</td>
                    <td>${cv.title}</td>
                    <td>${cv.mail}</td>
                    <td>${cv.phone}</td>
                    <td>${cv.dob}</td>
                    <td>${cv.gender}</td>
                    <td>${cv.education}</td>
                    <td>${cv.school}</td>
                    <td>${cv.major}</td>
                    <td>${cv.currentPosition}</td>
                    <td>${cv.experience}</td>
                    <td>${cv.appliedPosition}</td>
                    <td><button onclick="deleteCV(${idx})" class="delete-btn">X√≥a</button></td>
                </tr>`;
            });
        }

        function deleteCV(idx) {
            if (idx < cvList.length) {
                cvList.splice(idx, 1);
                localStorage.setItem('cvList', JSON.stringify(cvList));
                renderTable();
            }
        }

        // Event listeners
        document.addEventListener('DOMContentLoaded', function() {
            const saveBtn = document.getElementById('saveBtn');
            if (saveBtn) {
                saveBtn.onclick = function() {
                    if (currentCV) {
                        cvList.push(currentCV);
                        localStorage.setItem('cvList', JSON.stringify(cvList));
                        currentCV = null;
                        renderTable();
                        showSuccess('ƒê√£ l∆∞u th√¥ng tin CV th√†nh c√¥ng!');
                    }
                };
            }
            
            // Hi·ªÉn th·ªã d·ªØ li·ªáu ƒë√£ l∆∞u khi t·∫£i trang
            if (cvList.length > 0) {
                document.getElementById('resultsSection').style.display = 'block';
                renderTable();
            }
        });

        function translateKey(key) {
            const translations = {
                'name': 'H·ªç t√™n',
                'dateOfBirth': 'Ng√†y sinh',
                'gender': 'Gi·ªõi t√≠nh',
                'address': 'ƒê·ªãa ch·ªâ',
                'phone': 'ƒêi·ªán tho·∫°i',
                'email': 'Email',
                'linkedin': 'LinkedIn',
                'facebook': 'Facebook',
                'objective': 'M·ª•c ti√™u',
                'hobbies': 'S·ªü th√≠ch',
                'hasReferences': 'C√≥ ng∆∞·ªùi gi·ªõi thi·ªáu'
            };
            return translations[key] || key;
        }

        function showLoading(show) {
            loading.style.display = show ? 'block' : 'none';
        }

        function showError(message) {
            let errorDiv = document.querySelector('.error');
            if (!errorDiv) {
                errorDiv = document.createElement('div');
                errorDiv.className = 'error';
                uploadSection.appendChild(errorDiv);
            }
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }

        function hideError() {
            const errorDiv = document.querySelector('.error');
            if (errorDiv) {
                errorDiv.style.display = 'none';
            }
        }
        
        function showSuccess(message) {
            let successDiv = document.querySelector('.success');
            if (!successDiv) {
                successDiv = document.createElement('div');
                successDiv.className = 'success';
                uploadSection.appendChild(successDiv);
            }
            successDiv.textContent = message;
            successDiv.style.display = 'block';
            setTimeout(() => {
                successDiv.style.display = 'none';
            }, 3000);
        }
    </script>
</body>
</html>
